/*!
 * 
 *     ol-mapbox-style
 *     Copyright 2016-present Boundless Spatial
 *     CopyrightÂ© 2000-2018 SuperMap Software Co. Ltd
 *     github: https://github.com/boundlessgeo/ol-mapbox-style
 *     github: https://github.com/SuperMap/ol-mapbox-style
 *     license: BSD 2-Clause "Simplified" License
 *     version: v3.0.0-beta.7
 * 
 */
olms =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./olms.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./index.js":
/*!******************!*\
  !*** ./index.js ***!
  \******************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; /*\r\n                                                                                                                                                                                                                                                                              ol-mapbox-style - Use Mapbox Style objects with OpenLayers\r\n                                                                                                                                                                                                                                                                              Copyright 2016-present Boundless Spatial, Inc.\r\n                                                                                                                                                                                                                                                                              License: https://raw.githubusercontent.com/boundlessgeo/ol-mapbox-gl-style/master/LICENSE\r\n                                                                                                                                                                                                                                                                              */\n\nexports.applyStyle = applyStyle;\nexports.applyBackground = applyBackground;\nexports.apply = apply;\nexports.getLayer = getLayer;\nexports.getSource = getSource;\n\nvar _function = __webpack_require__(/*! @mapbox/mapbox-gl-style-spec/function */ \"./node_modules/@mapbox/mapbox-gl-style-spec/function/index.js\");\n\nvar _function2 = _interopRequireDefault(_function);\n\nvar _mapboxToCssFont = __webpack_require__(/*! mapbox-to-css-font */ \"./node_modules/mapbox-to-css-font/index.js\");\n\nvar _mapboxToCssFont2 = _interopRequireDefault(_mapboxToCssFont);\n\nvar _stylefunction = __webpack_require__(/*! ./stylefunction */ \"./stylefunction.js\");\n\nvar _stylefunction2 = _interopRequireDefault(_stylefunction);\n\nvar _google = __webpack_require__(/*! webfont-matcher/lib/fonts/google */ \"./node_modules/webfont-matcher/lib/fonts/google.js\");\n\nvar _google2 = _interopRequireDefault(_google);\n\nvar _proj = __webpack_require__(/*! ol/proj */ \"ol/proj\");\n\nvar _tilegrid = __webpack_require__(/*! ol/tilegrid */ \"ol/tilegrid\");\n\nvar _Map = __webpack_require__(/*! ol/Map */ \"ol/Map\");\n\nvar _Map2 = _interopRequireDefault(_Map);\n\nvar _GeoJSON = __webpack_require__(/*! ol/format/GeoJSON */ \"ol/format/GeoJSON\");\n\nvar _GeoJSON2 = _interopRequireDefault(_GeoJSON);\n\nvar _MVT = __webpack_require__(/*! ol/format/MVT */ \"ol/format/MVT\");\n\nvar _MVT2 = _interopRequireDefault(_MVT);\n\nvar _Observable = __webpack_require__(/*! ol/Observable */ \"ol/Observable\");\n\nvar _Tile = __webpack_require__(/*! ol/layer/Tile */ \"ol/layer/Tile\");\n\nvar _Tile2 = _interopRequireDefault(_Tile);\n\nvar _Vector = __webpack_require__(/*! ol/layer/Vector */ \"ol/layer/Vector\");\n\nvar _Vector2 = _interopRequireDefault(_Vector);\n\nvar _VectorTile = __webpack_require__(/*! ol/layer/VectorTile */ \"ol/layer/VectorTile\");\n\nvar _VectorTile2 = _interopRequireDefault(_VectorTile);\n\nvar _TileJSON = __webpack_require__(/*! ol/source/TileJSON */ \"ol/source/TileJSON\");\n\nvar _TileJSON2 = _interopRequireDefault(_TileJSON);\n\nvar _Vector3 = __webpack_require__(/*! ol/source/Vector */ \"ol/source/Vector\");\n\nvar _Vector4 = _interopRequireDefault(_Vector3);\n\nvar _VectorTile3 = __webpack_require__(/*! ol/source/VectorTile */ \"ol/source/VectorTile\");\n\nvar _VectorTile4 = _interopRequireDefault(_VectorTile3);\n\nvar _XYZ = __webpack_require__(/*! ol/source/XYZ */ \"ol/source/XYZ\");\n\nvar _XYZ2 = _interopRequireDefault(_XYZ);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar availableFonts;\n\nfunction loadFont(fonts) {\n  var i, ii;\n  if (!Array.isArray(fonts)) {\n    var stops = fonts.stops;\n    if (stops) {\n      for (i = 0, ii = stops.length; i < ii; ++i) {\n        loadFont(stops[i][1]);\n      }\n    }\n    return;\n  }\n  var googleFamilies = _google2.default.getNames();\n  var families = fonts.map(function (font) {\n    return (0, _mapboxToCssFont2.default)(font, 1).split(' 1px ')[1].replace(/\"/g, '');\n  });\n  for (i = 0, ii = families.length; i < ii; ++i) {\n    var family = families[i];\n    var font = fonts[i];\n    if (googleFamilies.indexOf(family) !== -1) {\n      if (!availableFonts) {\n        availableFonts = [];\n      }\n      if (availableFonts.indexOf(font) == -1) {\n        availableFonts.push(font);\n        var fontUrl = 'https://fonts.googleapis.com/css?family=' + family.replace(/ /g, '+');\n        if (!document.querySelector('link[href=\"' + fontUrl + '\"]')) {\n          var markup = document.createElement('link');\n          markup.href = fontUrl;\n          markup.rel = 'stylesheet';\n          document.getElementsByTagName('head')[0].appendChild(markup);\n        }\n      }\n      break;\n    }\n  }\n}\n\nvar defaultFont = ['Open Sans Regular', 'Arial Regular'];\n\nfunction preprocess(layer) {\n  if ('layout' in layer && 'text-field' in layer.layout) {\n    loadFont(layer.layout['text-font'] || defaultFont);\n  }\n}\n\nvar spriteRegEx = /^(.*)(\\?.*)$/;\n\nfunction withPath(url, path) {\n  if (path && url.indexOf('http') != 0) {\n    url = path + url;\n  }\n  return url;\n}\n\nfunction toSpriteUrl(url, path, extension) {\n  url = withPath(url, path);\n  var parts = url.match(spriteRegEx);\n  return parts ? parts[1] + extension + (parts.length > 2 ? parts[2] : '') : url + extension;\n}\n\n/**\r\n * Applies a style function to an `ol.layer.VectorTile` or `ol.layer.Vector`\r\n * with an `ol.source.VectorTile` or an `ol.source.Vector`. The style function\r\n * will render all layers from the `glStyle` object that use the specified\r\n * `source`, or a subset of layers from the same source. The source needs to be\r\n * a `\"type\": \"vector\"`, `\"type\": \"geojson\"` or `\"type\": \"raster\"` source.\r\n *\r\n * @param {ol.layer.VectorTile} layer OpenLayers layer.\r\n * @param {string|Object} glStyle Mapbox Style object.\r\n * @param {string} source `source` key or an array of layer `id`s from the\r\n * Mapbox Style object. When a `source` key is provided, all layers for the\r\n * specified source will be included in the style function. When layer `id`s\r\n * are provided, they must be from layers that use the same source.\r\n * @param {string} [path=undefined] Path of the style file. Only required when\r\n * a relative path is used with the `\"sprite\"` property of the style.\r\n * @param {Array<number>} [resolutions=undefined] Resolutions for mapping resolution to zoom level.\r\n * @return {Promise} Promise which will be resolved when the style can be used\r\n * for rendering.\r\n */\nfunction applyStyle(layer, glStyle, source, path, resolutions) {\n  return new Promise(function (resolve, reject) {\n\n    if ((typeof glStyle === 'undefined' ? 'undefined' : _typeof(glStyle)) != 'object') {\n      glStyle = JSON.parse(glStyle);\n    }\n    if (glStyle.version != 8) {\n      reject(new Error('glStyle version 8 required.'));\n    }\n    var spriteScale, spriteData, spriteImageUrl;\n    if (glStyle.sprite) {\n      spriteScale = window.devicePixelRatio >= 1.5 ? 0.5 : 1;\n      var sizeFactor = spriteScale == 0.5 ? '@2x' : '';\n      var spriteUrl = toSpriteUrl(glStyle.sprite, path, sizeFactor + '.json');\n\n      fetch(spriteUrl, { credentials: 'same-origin' }).then(function (response) {\n        // if the response is ready return the JSON promise\n        if (response.status === 200) {\n          return response.json();\n        } else if (sizeFactor !== '') {\n          // return the JSON promise for the low-resolution sprites.\n          sizeFactor = '';\n          spriteUrl = toSpriteUrl(glStyle.sprite, path, '.json');\n          return fetch(spriteUrl, { credentials: 'same-origin' }).then(function (r) {\n            return r.json();\n          });\n        }\n      }).then(function (spritesJson) {\n        if (spritesJson === undefined) {\n          throw 'No sprites found.';\n        }\n        spriteData = spritesJson;\n        spriteImageUrl = toSpriteUrl(glStyle.sprite, path, sizeFactor + '.png');\n        onChange();\n      }).catch(function (err) {\n        console.error(err);\n        reject(new Error('Sprites cannot be loaded from ' + spriteUrl));\n      });\n    }\n\n    var style;\n    function onChange() {\n      if (!style && (!glStyle.sprite || spriteData) && (!availableFonts || availableFonts.length > 0)) {\n        style = (0, _stylefunction2.default)(layer, glStyle, source, resolutions, spriteData, spriteImageUrl, availableFonts);\n        resolve();\n      } else if (style) {\n        layer.setStyle(style);\n      }\n    }\n\n    if (layer instanceof _VectorTile2.default || layer instanceof _Vector2.default) {\n      try {\n        var layers = glStyle.layers;\n        for (var i = 0, ii = layers.length; i < ii; ++i) {\n          if (typeof source == 'string' && layers[i].source == source || source.indexOf(layers[i].id) >= 0) {\n            preprocess(layers[i]);\n          }\n        }\n        onChange();\n      } catch (e) {\n        setTimeout(function () {\n          reject(e);\n        }, 0);\n      }\n    }\n  });\n}\n\nfunction setBackground(map, layer) {\n  function updateStyle() {\n    var element = map.getTargetElement();\n    if (!element) {\n      return;\n    }\n    var layout = layer.layout || {};\n    var paint = layer.paint || {};\n    var zoom = map.getView().getZoom();\n    if ('background-color' in paint) {\n      var bg = (0, _function2.default)(paint['background-color'], { function: 'interpolated', type: 'color' })(zoom);\n      if (Array.isArray(bg)) {\n        bg = 'rgba(' + Math.round(bg[0] * 255) + ',' + Math.round(bg[1] * 255) + ',' + Math.round(bg[2] * 255) + ',' + (bg[3] ? bg[3] : 1) + ')';\n      }\n      element.style.backgroundColor = bg;\n    }\n    if ('background-opacity' in paint) {\n      element.style.backgroundOpacity = (0, _function2.default)(paint['background-opacity'], { function: 'interpolated', type: 'number' })(zoom);\n    }\n    if (layout.visibility == 'none') {\n      element.style.backgroundColor = '';\n      element.style.backgroundOpacity = '';\n    }\n  }\n  if (map.getTargetElement()) {\n    updateStyle();\n  }\n  map.on(['change:resolution', 'change:target'], updateStyle);\n}\n\n/**\r\n * Applies properties of the Mapbox Style's first `background` layer to the map.\r\n * @param {ol.Map} map OpenLayers Map.\r\n * @param {Object} glStyle Mapbox Style object.\r\n */\nfunction applyBackground(map, glStyle) {\n  glStyle.layers.some(function (l) {\n    if (l.type == 'background') {\n      setBackground(map, l);\n      return true;\n    }\n  });\n}\n\nfunction getSourceIdByRef(layers, ref) {\n  var sourceId;\n  layers.some(function (layer) {\n    if (layer.id == ref) {\n      sourceId = layer.source;\n      return true;\n    }\n  });\n  return sourceId;\n}\n\nfunction processStyle(glStyle, map, baseUrl, host, path, accessToken) {\n  var view = map.getView();\n  if ('center' in glStyle && !view.getCenter()) {\n    view.setCenter((0, _proj.fromLonLat)(glStyle.center));\n  }\n  if ('zoom' in glStyle && view.getZoom() === undefined) {\n    view.setZoom(glStyle.zoom);\n  }\n  if (!view.getCenter() || view.getZoom() === undefined) {\n    view.fit(view.getProjection().getExtent(), {\n      nearest: true,\n      size: map.getSize()\n    });\n  }\n  if (glStyle.sprite) {\n    if (glStyle.sprite.indexOf('mapbox://') == 0) {\n      glStyle.sprite = baseUrl + '/sprite' + accessToken;\n    } else if (glStyle.sprite.indexOf('http') != 0) {\n      glStyle.sprite = (host ? host + path : '') + glStyle.sprite + accessToken;\n    }\n  }\n\n  var glLayers = glStyle.layers;\n  var geoJsonFormat = new _GeoJSON2.default();\n  var layerIds = [];\n\n  function finalizeLayer(layer) {\n    if (layerIds.length > 0) {\n      map.addLayer(layer);\n      var setStyle = function setStyle() {\n        applyStyle(layer, glStyle, layerIds, path).then(function () {\n          layer.setVisible(true);\n        }, function (e) {\n          /*eslint no-console: [\"error\", { allow: [\"error\"] }] */\n          console.error(e);\n        });\n      };\n      if (layer.getSource()) {\n        setStyle();\n      } else {\n        layer.once('change:source', setStyle);\n      }\n    }\n  }\n\n  var glLayer, glSource, glSourceId, id, layer, mapid, url;\n  for (var i = 0, ii = glLayers.length; i < ii; ++i) {\n    glLayer = glLayers[i];\n    if (glLayer.type == 'background') {\n      setBackground(map, glLayer);\n    } else {\n      id = glLayer.source || getSourceIdByRef(glLayers, glLayer.ref);\n      if (id != glSourceId) {\n        finalizeLayer(layer);\n        layerIds = [];\n        glSource = glStyle.sources[id];\n        url = glSource.url;\n        var tiles = glSource.tiles;\n        if (url) {\n          if (url.indexOf('mapbox://') == 0) {\n            mapid = url.replace('mapbox://', '');\n            tiles = ['a', 'b', 'c', 'd'].map(function (host) {\n              return 'https://' + host + '.tiles.mapbox.com/v4/' + mapid + '/{z}/{x}/{y}.' + (glSource.type == 'vector' ? 'vector.pbf' : 'png') + accessToken;\n            });\n          }\n        }\n\n        if (glSource.type == 'vector') {\n          layer = tiles ? function () {\n            var tileGrid = (0, _tilegrid.createXYZ)({\n              tileSize: 512,\n              maxZoom: 'maxzoom' in glSource ? glSource.maxzoom : 22,\n              minZoom: glSource.minzoom\n            });\n            return new _VectorTile2.default({\n              declutter: true,\n              maxResolution: tileGrid.getMinZoom() > 0 ? tileGrid.getResolution(tileGrid.getMinZoom()) : undefined,\n              source: new _VectorTile4.default({\n                attributions: glSource.attribution,\n                format: new _MVT2.default(),\n                tileGrid: tileGrid,\n                urls: tiles\n              }),\n              visible: false,\n              zIndex: i\n            });\n          }() : function () {\n            var layer = new _VectorTile2.default({\n              declutter: true,\n              visible: false,\n              zIndex: i\n            });\n            var tilejson = new _TileJSON2.default({\n              url: url\n            });\n            var key = tilejson.on('change', function () {\n              if (tilejson.getState() == 'ready') {\n                var tileJSONDoc = tilejson.getTileJSON();\n                var tiles = Array.isArray(tileJSONDoc.tiles) ? tileJSONDoc.tiles : [tileJSONDoc.tiles];\n                for (var i = 0, ii = tiles.length; i < ii; ++i) {\n                  var tile = tiles[i];\n                  if (tile.indexOf('http') != 0) {\n                    tiles[i] = glSource.url + tile;\n                  }\n                }\n                var tileGrid = tilejson.getTileGrid();\n                layer.setSource(new _VectorTile4.default({\n                  attributions: tilejson.getAttributions() || tileJSONDoc.attribution,\n                  format: new _MVT2.default(),\n                  tileGrid: (0, _tilegrid.createXYZ)({\n                    minZoom: tileGrid.getMinZoom(),\n                    maxZoom: tileGrid.getMaxZoom(),\n                    tileSize: 512\n                  }),\n                  urls: tiles\n                }));\n                if (tileGrid.getMinZoom() > 0) {\n                  layer.setMaxResolution(tileGrid.getResolution(tileGrid.getMinZoom()));\n                }\n                (0, _Observable.unByKey)(key);\n              }\n            });\n            return layer;\n          }();\n        } else if (glSource.type == 'raster') {\n          var source;\n          if (!glSource.tiles) {\n            source = function () {\n              return new _TileJSON2.default({\n                url: url,\n                crossOrigin: 'anonymous'\n              });\n            }();\n          } else {\n            source = new _XYZ2.default({\n              attributions: glSource.attribution,\n              minZoom: glSource.minzoom,\n              maxZoom: 'maxzoom' in glSource ? glSource.maxzoom : 22,\n              tileSize: glSource.tileSize || 512,\n              url: url,\n              urls: glSource.tiles,\n              crossOrigin: 'anonymous'\n            });\n          }\n          source.setTileLoadFunction(function (tile, src) {\n            if (src.indexOf('{bbox-epsg-3857}') != -1) {\n              var bbox = source.getTileGrid().getTileCoordExtent(tile.getTileCoord());\n              src = src.replace('{bbox-epsg-3857}', bbox.toString());\n            }\n            tile.getImage().src = src;\n          });\n          layer = new _Tile2.default({\n            source: source,\n            visible: glLayer.layout ? glLayer.layout.visibility !== 'none' : true\n          });\n        } else if (glSource.type == 'geojson') {\n          var data = glSource.data;\n          var features, geoJsonUrl;\n          if (typeof data == 'string') {\n            geoJsonUrl = withPath(data, path);\n          } else {\n            features = geoJsonFormat.readFeatures(data, { featureProjection: 'EPSG:3857' });\n          }\n          layer = new _Vector2.default({\n            source: new _Vector4.default({\n              attributions: glSource.attribution,\n              features: features,\n              format: geoJsonFormat,\n              url: geoJsonUrl\n            }),\n            visible: false,\n            zIndex: i\n          });\n        }\n        glSourceId = id;\n      }\n      layerIds.push(glLayer.id);\n    }\n  }\n  finalizeLayer(layer);\n  map.set('mapbox-style', glStyle);\n}\n\n/**\r\n * Loads and applies a Mapbox Style object to an OpenLayers Map. This includes\r\n * the map background, the layers, the center and the zoom.\r\n *\r\n * The center and zoom will only be set if present in the Mapbox Style document,\r\n * and if not already set on the OpenLayers map.\r\n *\r\n * Layers will be added to the OpenLayers map, without affecting any layers that\r\n * might already be set on the map.\r\n *\r\n * Layers added by `apply()` will have two additional properties:\r\n *\r\n *  * `mapbox-source`: The `id` of the Mapbox Style document's source that the\r\n *    OpenLayers layer was created from. Usually `apply()` creates one\r\n *    OpenLayers layer per Mapbox Style source, unless the layer stack has\r\n *    layers from different sources in between.\r\n *  * `mapbox-layers`: The `id`s of the Mapbox Style document's layers that are\r\n *    included in the OpenLayers layer.\r\n *\r\n * The map returned by this function will have an additional `mapbox-style`\r\n * property which holds the Mapbox Style object.\r\n *\r\n * @param {ol.Map|HTMLElement|string} map Either an existing OpenLayers Map\r\n * instance, or a HTML element, or the id of a HTML element that will be the\r\n * target of a new OpenLayers Map.\r\n * @param {string|Object} style JSON style object or style url pointing to a\r\n * Mapbox Style object. When using Mapbox APIs, the url must contain an access\r\n * token and look like\r\n * `https://api.mapbox.com/styles/v1/mapbox/bright-v9?access_token=[your_access_token_here]`.\r\n * When passed as JSON style object, all OpenLayers layers created by `apply()`\r\n * will be immediately available, but they may not have a source yet (i.e. when\r\n * they are defined by a TileJSON url in the Mapbox Style document). When passed\r\n * as style url, layers will be added to the map when the Mapbox Style document\r\n * is loaded and parsed.\r\n * @return {ol.Map} The OpenLayers Map instance that will be populated with the\r\n * contents described in the Mapbox Style object.\r\n */\nfunction apply(map, style) {\n\n  var accessToken, baseUrl, host, path;\n  accessToken = baseUrl = host = path = '';\n\n  if (!(map instanceof _Map2.default)) {\n    map = new _Map2.default({\n      target: map\n    });\n  }\n\n  if (typeof style === 'string') {\n    var parts = style.match(spriteRegEx);\n    if (parts) {\n      baseUrl = parts[1];\n      accessToken = parts.length > 2 ? parts[2] : '';\n    }\n\n    fetch(style, {\n      credentials: 'same-origin'\n    }).then(function (response) {\n      return response.json();\n    }).then(function (glStyle) {\n      var a = document.createElement('A');\n      a.href = style;\n      path = a.pathname.split('/').slice(0, -1).join('/') + '/';\n      host = style.substr(0, style.indexOf(path));\n\n      processStyle(glStyle, map, baseUrl, host, path, accessToken);\n    }).catch(function (err) {\n      console.error(err);\n      throw new Error('Could not load ' + style);\n    });\n  } else {\n    setTimeout(function () {\n      processStyle(style, map);\n    }, 0);\n  }\n  return map;\n}\n\n/**\r\n * Get the OpenLayers layer instance that contains the provided Mapbox Style\r\n * `layer`. Note that multiple Mapbox Style layers are combined in a single\r\n * OpenLayers layer instance when they use the same Mapbox Style `source`.\r\n * @param {ol.Map} map OpenLayers Map.\r\n * @param {string} layerId Mapbox Style layer id.\r\n * @return {ol.layer.Layer} layer OpenLayers layer instance.\r\n */\nfunction getLayer(map, layerId) {\n  var layers = map.getLayers().getArray();\n  for (var i = 0, ii = layers.length; i < ii; ++i) {\n    if (layers[i].get('mapbox-layers').indexOf(layerId) !== -1) {\n      return layers[i];\n    }\n  }\n}\n\n/**\r\n * Get the OpenLayers source instance for the provided Mapbox Style `source`.\r\n * @param {ol.Map} map OpenLayers Map.\r\n * @param {string} sourceId Mapbox Style source id.\r\n * @return {ol.layer.Layer} layer OpenLayers layer instance.\r\n */\nfunction getSource(map, sourceId) {\n  var layers = map.getLayers().getArray();\n  for (var i = 0, ii = layers.length; i < ii; ++i) {\n    var source = layers[i].getSource();\n    if (layers[i].get('mapbox-source').indexOf(sourceId) !== -1) {\n      return source;\n    }\n  }\n}\n\n//# sourceURL=webpack://olms/./index.js?");

/***/ }),

/***/ "./node_modules/@mapbox/mapbox-gl-style-spec/deref.js":
/*!************************************************************!*\
  !*** ./node_modules/@mapbox/mapbox-gl-style-spec/deref.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar refProperties = __webpack_require__(/*! ./util/ref_properties */ \"./node_modules/@mapbox/mapbox-gl-style-spec/util/ref_properties.js\");\n\nfunction deref(layer, parent) {\n    var result = {};\n\n    for (var k in layer) {\n        if (k !== 'ref') {\n            result[k] = layer[k];\n        }\n    }\n\n    refProperties.forEach(function (k) {\n        if (k in parent) {\n            result[k] = parent[k];\n        }\n    });\n\n    return result;\n}\n\nmodule.exports = derefLayers;\n\n/**\n * Given an array of layers, some of which may contain `ref` properties\n * whose value is the `id` of another property, return a new array where\n * such layers have been augmented with the 'type', 'source', etc. properties\n * from the parent layer, and the `ref` property has been removed.\n *\n * The input is not modified. The output may contain references to portions\n * of the input.\n *\n * @private\n * @param {Array<Layer>} layers\n * @returns {Array<Layer>}\n */\nfunction derefLayers(layers) {\n    layers = layers.slice();\n\n    var map = Object.create(null);\n    for (var i = 0; i < layers.length; i++) {\n        map[layers[i].id] = layers[i];\n    }\n\n    for (var _i = 0; _i < layers.length; _i++) {\n        if ('ref' in layers[_i]) {\n            layers[_i] = deref(layers[_i], map[layers[_i].ref]);\n        }\n    }\n\n    return layers;\n}\n\n//# sourceURL=webpack://olms/./node_modules/@mapbox/mapbox-gl-style-spec/deref.js?");

/***/ }),

/***/ "./node_modules/@mapbox/mapbox-gl-style-spec/feature_filter/index.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@mapbox/mapbox-gl-style-spec/feature_filter/index.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nmodule.exports = createFilter;\n\nvar types = ['Unknown', 'Point', 'LineString', 'Polygon'];\n\n/**\n * Given a filter expressed as nested arrays, return a new function\n * that evaluates whether a given feature (with a .properties or .tags property)\n * passes its test.\n *\n * @private\n * @param {Array} filter mapbox gl filter\n * @returns {Function} filter-evaluating function\n */\nfunction createFilter(filter) {\n    return new Function('f', 'var p = (f && f.properties || {}); return ' + compile(filter));\n}\n\nfunction compile(filter) {\n    if (!filter) return 'true';\n    var op = filter[0];\n    if (filter.length <= 1) return op === 'any' ? 'false' : 'true';\n    var str = op === '==' ? compileComparisonOp(filter[1], filter[2], '===', false) : op === '!=' ? compileComparisonOp(filter[1], filter[2], '!==', false) : op === '<' || op === '>' || op === '<=' || op === '>=' ? compileComparisonOp(filter[1], filter[2], op, true) : op === 'any' ? compileLogicalOp(filter.slice(1), '||') : op === 'all' ? compileLogicalOp(filter.slice(1), '&&') : op === 'none' ? compileNegation(compileLogicalOp(filter.slice(1), '||')) : op === 'in' ? compileInOp(filter[1], filter.slice(2)) : op === '!in' ? compileNegation(compileInOp(filter[1], filter.slice(2))) : op === 'has' ? compileHasOp(filter[1]) : op === '!has' ? compileNegation(compileHasOp(filter[1])) : 'true';\n    return '(' + str + ')';\n}\n\nfunction compilePropertyReference(property) {\n    var ref = property === '$type' ? 'f.type' : property === '$id' ? 'f.id' : 'p[' + JSON.stringify(property) + ']';\n    return ref;\n}\n\nfunction compileComparisonOp(property, value, op, checkType) {\n    var left = compilePropertyReference(property);\n    var right = property === '$type' ? types.indexOf(value) : JSON.stringify(value);\n    return (checkType ? 'typeof ' + left + '=== typeof ' + right + '&&' : '') + left + op + right;\n}\n\nfunction compileLogicalOp(expressions, op) {\n    return expressions.map(compile).join(op);\n}\n\nfunction compileInOp(property, values) {\n    if (property === '$type') values = values.map(function (value) {\n        return types.indexOf(value);\n    });\n    var left = JSON.stringify(values.sort(compare));\n    var right = compilePropertyReference(property);\n\n    if (values.length <= 200) return left + '.indexOf(' + right + ') !== -1';\n\n    return '' + ('function(v, a, i, j) {' + 'while (i <= j) { var m = (i + j) >> 1;' + '    if (a[m] === v) return true; if (a[m] > v) j = m - 1; else i = m + 1;' + '}' + 'return false; }(') + right + ', ' + left + ',0,' + (values.length - 1) + ')';\n}\n\nfunction compileHasOp(property) {\n    return property === '$id' ? '\"id\" in f' : JSON.stringify(property) + ' in p';\n}\n\nfunction compileNegation(expression) {\n    return '!(' + expression + ')';\n}\n\n// Comparison function to sort numbers and strings\nfunction compare(a, b) {\n    return a < b ? -1 : a > b ? 1 : 0;\n}\n\n//# sourceURL=webpack://olms/./node_modules/@mapbox/mapbox-gl-style-spec/feature_filter/index.js?");

/***/ }),

/***/ "./node_modules/@mapbox/mapbox-gl-style-spec/function/color_spaces.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@mapbox/mapbox-gl-style-spec/function/color_spaces.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n// Constants\nvar Xn = 0.950470,\n    // D65 standard referent\nYn = 1,\n    Zn = 1.088830,\n    t0 = 4 / 29,\n    t1 = 6 / 29,\n    t2 = 3 * t1 * t1,\n    t3 = t1 * t1 * t1,\n    deg2rad = Math.PI / 180,\n    rad2deg = 180 / Math.PI;\n\n// Utilities\nfunction xyz2lab(t) {\n    return t > t3 ? Math.pow(t, 1 / 3) : t / t2 + t0;\n}\n\nfunction lab2xyz(t) {\n    return t > t1 ? t * t * t : t2 * (t - t0);\n}\n\nfunction xyz2rgb(x) {\n    return 255 * (x <= 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055);\n}\n\nfunction rgb2xyz(x) {\n    x /= 255;\n    return x <= 0.04045 ? x / 12.92 : Math.pow((x + 0.055) / 1.055, 2.4);\n}\n\n// LAB\nfunction rgbToLab(rgbColor) {\n    var b = rgb2xyz(rgbColor[0]),\n        a = rgb2xyz(rgbColor[1]),\n        l = rgb2xyz(rgbColor[2]),\n        x = xyz2lab((0.4124564 * b + 0.3575761 * a + 0.1804375 * l) / Xn),\n        y = xyz2lab((0.2126729 * b + 0.7151522 * a + 0.0721750 * l) / Yn),\n        z = xyz2lab((0.0193339 * b + 0.1191920 * a + 0.9503041 * l) / Zn);\n\n    return [116 * y - 16, 500 * (x - y), 200 * (y - z), rgbColor[3]];\n}\n\nfunction labToRgb(labColor) {\n    var y = (labColor[0] + 16) / 116,\n        x = isNaN(labColor[1]) ? y : y + labColor[1] / 500,\n        z = isNaN(labColor[2]) ? y : y - labColor[2] / 200;\n    y = Yn * lab2xyz(y);\n    x = Xn * lab2xyz(x);\n    z = Zn * lab2xyz(z);\n    return [xyz2rgb(3.2404542 * x - 1.5371385 * y - 0.4985314 * z), // D65 -> sRGB\n    xyz2rgb(-0.9692660 * x + 1.8760108 * y + 0.0415560 * z), xyz2rgb(0.0556434 * x - 0.2040259 * y + 1.0572252 * z), labColor[3]];\n}\n\n// HCL\nfunction rgbToHcl(rgbColor) {\n    var labColor = rgbToLab(rgbColor);\n    var l = labColor[0],\n        a = labColor[1],\n        b = labColor[2];\n    var h = Math.atan2(b, a) * rad2deg;\n    return [h < 0 ? h + 360 : h, Math.sqrt(a * a + b * b), l, rgbColor[3]];\n}\n\nfunction hclToRgb(hclColor) {\n    var h = hclColor[0] * deg2rad,\n        c = hclColor[1],\n        l = hclColor[2];\n    return labToRgb([l, Math.cos(h) * c, Math.sin(h) * c, hclColor[3]]);\n}\n\nmodule.exports = {\n    lab: {\n        forward: rgbToLab,\n        reverse: labToRgb\n    },\n    hcl: {\n        forward: rgbToHcl,\n        reverse: hclToRgb\n    }\n};\n\n//# sourceURL=webpack://olms/./node_modules/@mapbox/mapbox-gl-style-spec/function/color_spaces.js?");

/***/ }),

/***/ "./node_modules/@mapbox/mapbox-gl-style-spec/function/index.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@mapbox/mapbox-gl-style-spec/function/index.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar colorSpaces = __webpack_require__(/*! ./color_spaces */ \"./node_modules/@mapbox/mapbox-gl-style-spec/function/color_spaces.js\");\nvar parseColor = __webpack_require__(/*! ../util/parse_color */ \"./node_modules/@mapbox/mapbox-gl-style-spec/util/parse_color.js\");\nvar extend = __webpack_require__(/*! ../util/extend */ \"./node_modules/@mapbox/mapbox-gl-style-spec/util/extend.js\");\nvar getType = __webpack_require__(/*! ../util/get_type */ \"./node_modules/@mapbox/mapbox-gl-style-spec/util/get_type.js\");\nvar interpolate = __webpack_require__(/*! ../util/interpolate */ \"./node_modules/@mapbox/mapbox-gl-style-spec/util/interpolate.js\");\n\nfunction identityFunction(x) {\n    return x;\n}\n\nfunction createFunction(parameters, propertySpec) {\n    var isColor = propertySpec.type === 'color';\n\n    var fun = void 0;\n\n    if (!isFunctionDefinition(parameters)) {\n        if (isColor && parameters) {\n            parameters = parseColor(parameters);\n        }\n        fun = function fun() {\n            return parameters;\n        };\n        fun.isFeatureConstant = true;\n        fun.isZoomConstant = true;\n    } else {\n        var zoomAndFeatureDependent = parameters.stops && _typeof(parameters.stops[0][0]) === 'object';\n        var featureDependent = zoomAndFeatureDependent || parameters.property !== undefined;\n        var zoomDependent = zoomAndFeatureDependent || !featureDependent;\n        var type = parameters.type || (propertySpec.function === 'interpolated' ? 'exponential' : 'interval');\n\n        if (isColor) {\n            parameters = extend({}, parameters);\n\n            if (parameters.stops) {\n                parameters.stops = parameters.stops.map(function (stop) {\n                    return [stop[0], parseColor(stop[1])];\n                });\n            }\n\n            if (parameters.default) {\n                parameters.default = parseColor(parameters.default);\n            } else {\n                parameters.default = parseColor(propertySpec.default);\n            }\n        }\n\n        var innerFun = void 0;\n        var hashedStops = void 0;\n        var categoricalKeyType = void 0;\n        if (type === 'exponential') {\n            innerFun = evaluateExponentialFunction;\n        } else if (type === 'interval') {\n            innerFun = evaluateIntervalFunction;\n        } else if (type === 'categorical') {\n            innerFun = evaluateCategoricalFunction;\n\n            // For categorical functions, generate an Object as a hashmap of the stops for fast searching\n            hashedStops = Object.create(null);\n            var _iteratorNormalCompletion = true;\n            var _didIteratorError = false;\n            var _iteratorError = undefined;\n\n            try {\n                for (var _iterator = parameters.stops[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                    var stop = _step.value;\n\n                    hashedStops[stop[0]] = stop[1];\n                }\n\n                // Infer key type based on first stop key-- used to encforce strict type checking later\n            } catch (err) {\n                _didIteratorError = true;\n                _iteratorError = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion && _iterator.return) {\n                        _iterator.return();\n                    }\n                } finally {\n                    if (_didIteratorError) {\n                        throw _iteratorError;\n                    }\n                }\n            }\n\n            categoricalKeyType = _typeof(parameters.stops[0][0]);\n        } else if (type === 'identity') {\n            innerFun = evaluateIdentityFunction;\n        } else {\n            throw new Error('Unknown function type \"' + type + '\"');\n        }\n\n        var outputFunction = void 0;\n\n        // If we're interpolating colors in a color system other than RGBA,\n        // first translate all stop values to that color system, then interpolate\n        // arrays as usual. The `outputFunction` option lets us then translate\n        // the result of that interpolation back into RGBA.\n        if (parameters.colorSpace && parameters.colorSpace !== 'rgb') {\n            if (colorSpaces[parameters.colorSpace]) {\n                var colorspace = colorSpaces[parameters.colorSpace];\n                // Avoid mutating the parameters value\n                parameters = JSON.parse(JSON.stringify(parameters));\n                for (var s = 0; s < parameters.stops.length; s++) {\n                    parameters.stops[s] = [parameters.stops[s][0], colorspace.forward(parameters.stops[s][1])];\n                }\n                outputFunction = colorspace.reverse;\n            } else {\n                throw new Error('Unknown color space: ' + parameters.colorSpace);\n            }\n        } else {\n            outputFunction = identityFunction;\n        }\n\n        if (zoomAndFeatureDependent) {\n            var featureFunctions = {};\n            var zoomStops = [];\n            for (var _s = 0; _s < parameters.stops.length; _s++) {\n                var _stop = parameters.stops[_s];\n                var zoom = _stop[0].zoom;\n                if (featureFunctions[zoom] === undefined) {\n                    featureFunctions[zoom] = {\n                        zoom: zoom,\n                        type: parameters.type,\n                        property: parameters.property,\n                        default: parameters.default,\n                        stops: []\n                    };\n                    zoomStops.push(zoom);\n                }\n                featureFunctions[zoom].stops.push([_stop[0].value, _stop[1]]);\n            }\n\n            var featureFunctionStops = [];\n            var _iteratorNormalCompletion2 = true;\n            var _didIteratorError2 = false;\n            var _iteratorError2 = undefined;\n\n            try {\n                for (var _iterator2 = zoomStops[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n                    var z = _step2.value;\n\n                    featureFunctionStops.push([featureFunctions[z].zoom, createFunction(featureFunctions[z], propertySpec)]);\n                }\n            } catch (err) {\n                _didIteratorError2 = true;\n                _iteratorError2 = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion2 && _iterator2.return) {\n                        _iterator2.return();\n                    }\n                } finally {\n                    if (_didIteratorError2) {\n                        throw _iteratorError2;\n                    }\n                }\n            }\n\n            fun = function fun(zoom, feature) {\n                return outputFunction(evaluateExponentialFunction({\n                    stops: featureFunctionStops,\n                    base: parameters.base\n                }, propertySpec, zoom)(zoom, feature));\n            };\n            fun.isFeatureConstant = false;\n            fun.isZoomConstant = false;\n        } else if (zoomDependent) {\n            fun = function fun(zoom) {\n                return outputFunction(innerFun(parameters, propertySpec, zoom, hashedStops, categoricalKeyType));\n            };\n            fun.isFeatureConstant = true;\n            fun.isZoomConstant = false;\n        } else {\n            fun = function fun(zoom, feature) {\n                var value = feature[parameters.property];\n                if (value === undefined) {\n                    return coalesce(parameters.default, propertySpec.default);\n                }\n                return outputFunction(innerFun(parameters, propertySpec, value, hashedStops, categoricalKeyType));\n            };\n            fun.isFeatureConstant = false;\n            fun.isZoomConstant = true;\n        }\n    }\n\n    return fun;\n}\n\nfunction coalesce(a, b, c) {\n    if (a !== undefined) return a;\n    if (b !== undefined) return b;\n    if (c !== undefined) return c;\n}\n\nfunction evaluateCategoricalFunction(parameters, propertySpec, input, hashedStops, keyType) {\n    var evaluated = (typeof input === 'undefined' ? 'undefined' : _typeof(input)) === keyType ? hashedStops[input] : undefined; // Enforce strict typing on input\n    return coalesce(evaluated, parameters.default, propertySpec.default);\n}\n\nfunction evaluateIntervalFunction(parameters, propertySpec, input) {\n    // Edge cases\n    if (getType(input) !== 'number') return coalesce(parameters.default, propertySpec.default);\n    var n = parameters.stops.length;\n    if (n === 1) return parameters.stops[0][1];\n    if (input <= parameters.stops[0][0]) return parameters.stops[0][1];\n    if (input >= parameters.stops[n - 1][0]) return parameters.stops[n - 1][1];\n\n    var index = findStopLessThanOrEqualTo(parameters.stops, input);\n\n    return parameters.stops[index][1];\n}\n\nfunction evaluateExponentialFunction(parameters, propertySpec, input) {\n    var base = parameters.base !== undefined ? parameters.base : 1;\n\n    // Edge cases\n    if (getType(input) !== 'number') return coalesce(parameters.default, propertySpec.default);\n    var n = parameters.stops.length;\n    if (n === 1) return parameters.stops[0][1];\n    if (input <= parameters.stops[0][0]) return parameters.stops[0][1];\n    if (input >= parameters.stops[n - 1][0]) return parameters.stops[n - 1][1];\n\n    var index = findStopLessThanOrEqualTo(parameters.stops, input);\n    var t = interpolationFactor(input, base, parameters.stops[index][0], parameters.stops[index + 1][0]);\n\n    var outputLower = parameters.stops[index][1];\n    var outputUpper = parameters.stops[index + 1][1];\n    var interp = interpolate[propertySpec.type] || identityFunction;\n\n    if (typeof outputLower === 'function') {\n        return function () {\n            for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n                args[_key] = arguments[_key];\n            }\n\n            var evaluatedLower = outputLower.apply(undefined, args);\n            var evaluatedUpper = outputUpper.apply(undefined, args);\n            // Special case for fill-outline-color, which has no spec default.\n            if (evaluatedLower === undefined || evaluatedUpper === undefined) {\n                return undefined;\n            }\n            return interp(evaluatedLower, evaluatedUpper, t);\n        };\n    }\n\n    return interp(outputLower, outputUpper, t);\n}\n\nfunction evaluateIdentityFunction(parameters, propertySpec, input) {\n    if (propertySpec.type === 'color') {\n        input = parseColor(input);\n    } else if (getType(input) !== propertySpec.type && (propertySpec.type !== 'enum' || !propertySpec.values[input])) {\n        input = undefined;\n    }\n    return coalesce(input, parameters.default, propertySpec.default);\n}\n\n/**\n * Returns the index of the last stop <= input, or 0 if it doesn't exist.\n *\n * @private\n */\nfunction findStopLessThanOrEqualTo(stops, input) {\n    var n = stops.length;\n    var lowerIndex = 0;\n    var upperIndex = n - 1;\n    var currentIndex = 0;\n    var currentValue = void 0,\n        upperValue = void 0;\n\n    while (lowerIndex <= upperIndex) {\n        currentIndex = Math.floor((lowerIndex + upperIndex) / 2);\n        currentValue = stops[currentIndex][0];\n        upperValue = stops[currentIndex + 1][0];\n        if (input === currentValue || input > currentValue && input < upperValue) {\n            // Search complete\n            return currentIndex;\n        } else if (currentValue < input) {\n            lowerIndex = currentIndex + 1;\n        } else if (currentValue > input) {\n            upperIndex = currentIndex - 1;\n        }\n    }\n\n    return Math.max(currentIndex - 1, 0);\n}\n\nfunction isFunctionDefinition(value) {\n    return (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object' && (value.stops || value.type === 'identity');\n}\n\n/**\n * Returns a ratio that can be used to interpolate between exponential function\n * stops.\n *\n * How it works:\n * Two consecutive stop values define a (scaled and shifted) exponential\n * function `f(x) = a * base^x + b`, where `base` is the user-specified base,\n * and `a` and `b` are constants affording sufficient degrees of freedom to fit\n * the function to the given stops.\n *\n * Here's a bit of algebra that lets us compute `f(x)` directly from the stop\n * values without explicitly solving for `a` and `b`:\n *\n * First stop value: `f(x0) = y0 = a * base^x0 + b`\n * Second stop value: `f(x1) = y1 = a * base^x1 + b`\n * => `y1 - y0 = a(base^x1 - base^x0)`\n * => `a = (y1 - y0)/(base^x1 - base^x0)`\n *\n * Desired value: `f(x) = y = a * base^x + b`\n * => `f(x) = y0 + a * (base^x - base^x0)`\n *\n * From the above, we can replace the `a` in `a * (base^x - base^x0)` and do a\n * little algebra:\n * ```\n * a * (base^x - base^x0) = (y1 - y0)/(base^x1 - base^x0) * (base^x - base^x0)\n *                     = (y1 - y0) * (base^x - base^x0) / (base^x1 - base^x0)\n * ```\n *\n * If we let `(base^x - base^x0) / (base^x1 base^x0)`, then we have\n * `f(x) = y0 + (y1 - y0) * ratio`.  In other words, `ratio` may be treated as\n * an interpolation factor between the two stops' output values.\n *\n * (Note: a slightly different form for `ratio`,\n * `(base^(x-x0) - 1) / (base^(x1-x0) - 1) `, is equivalent, but requires fewer\n * expensive `Math.pow()` operations.)\n *\n * @private\n*/\nfunction interpolationFactor(input, base, lowerValue, upperValue) {\n    var difference = upperValue - lowerValue;\n    var progress = input - lowerValue;\n\n    if (difference === 0) {\n        return 0;\n    } else if (base === 1) {\n        return progress / difference;\n    } else {\n        return (Math.pow(base, progress) - 1) / (Math.pow(base, difference) - 1);\n    }\n}\n\nmodule.exports = createFunction;\nmodule.exports.isFunctionDefinition = isFunctionDefinition;\nmodule.exports.interpolationFactor = interpolationFactor;\nmodule.exports.findStopLessThanOrEqualTo = findStopLessThanOrEqualTo;\n\n//# sourceURL=webpack://olms/./node_modules/@mapbox/mapbox-gl-style-spec/function/index.js?");

/***/ }),

/***/ "./node_modules/@mapbox/mapbox-gl-style-spec/util/extend.js":
/*!******************************************************************!*\
  !*** ./node_modules/@mapbox/mapbox-gl-style-spec/util/extend.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nmodule.exports = function (output) {\n    for (var _len = arguments.length, inputs = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        inputs[_key - 1] = arguments[_key];\n    }\n\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n        for (var _iterator = inputs[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n            var input = _step.value;\n\n            for (var k in input) {\n                output[k] = input[k];\n            }\n        }\n    } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n    } finally {\n        try {\n            if (!_iteratorNormalCompletion && _iterator.return) {\n                _iterator.return();\n            }\n        } finally {\n            if (_didIteratorError) {\n                throw _iteratorError;\n            }\n        }\n    }\n\n    return output;\n};\n\n//# sourceURL=webpack://olms/./node_modules/@mapbox/mapbox-gl-style-spec/util/extend.js?");

/***/ }),

/***/ "./node_modules/@mapbox/mapbox-gl-style-spec/util/get_type.js":
/*!********************************************************************!*\
  !*** ./node_modules/@mapbox/mapbox-gl-style-spec/util/get_type.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nmodule.exports = function getType(val) {\n    if (val instanceof Number) {\n        return 'number';\n    } else if (val instanceof String) {\n        return 'string';\n    } else if (val instanceof Boolean) {\n        return 'boolean';\n    } else if (Array.isArray(val)) {\n        return 'array';\n    } else if (val === null) {\n        return 'null';\n    } else {\n        return typeof val === 'undefined' ? 'undefined' : _typeof(val);\n    }\n};\n\n//# sourceURL=webpack://olms/./node_modules/@mapbox/mapbox-gl-style-spec/util/get_type.js?");

/***/ }),

/***/ "./node_modules/@mapbox/mapbox-gl-style-spec/util/interpolate.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@mapbox/mapbox-gl-style-spec/util/interpolate.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nmodule.exports = interpolate;\n\nfunction interpolate(a, b, t) {\n    return a * (1 - t) + b * t;\n}\n\ninterpolate.number = interpolate;\n\ninterpolate.vec2 = function (from, to, t) {\n    return [interpolate(from[0], to[0], t), interpolate(from[1], to[1], t)];\n};\n\n/*\n * Interpolate between two colors given as 4-element arrays.\n *\n * @param {Color} from\n * @param {Color} to\n * @param {number} t interpolation factor between 0 and 1\n * @returns {Color} interpolated color\n */\ninterpolate.color = function (from, to, t) {\n    return [interpolate(from[0], to[0], t), interpolate(from[1], to[1], t), interpolate(from[2], to[2], t), interpolate(from[3], to[3], t)];\n};\n\ninterpolate.array = function (from, to, t) {\n    return from.map(function (d, i) {\n        return interpolate(d, to[i], t);\n    });\n};\n\n//# sourceURL=webpack://olms/./node_modules/@mapbox/mapbox-gl-style-spec/util/interpolate.js?");

/***/ }),

/***/ "./node_modules/@mapbox/mapbox-gl-style-spec/util/parse_color.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@mapbox/mapbox-gl-style-spec/util/parse_color.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar parseColorString = __webpack_require__(/*! csscolorparser */ \"./node_modules/csscolorparser/csscolorparser.js\").parseCSSColor;\n\nmodule.exports = function parseColor(input) {\n    if (typeof input === 'string') {\n        var rgba = parseColorString(input);\n        if (!rgba) {\n            return undefined;\n        }\n\n        // GL expects all components to be in the range [0, 1] and to be\n        // multipled by the alpha value.\n        return [rgba[0] / 255 * rgba[3], rgba[1] / 255 * rgba[3], rgba[2] / 255 * rgba[3], rgba[3]];\n    } else if (Array.isArray(input)) {\n        return input;\n    } else {\n        return undefined;\n    }\n};\n\n//# sourceURL=webpack://olms/./node_modules/@mapbox/mapbox-gl-style-spec/util/parse_color.js?");

/***/ }),

/***/ "./node_modules/@mapbox/mapbox-gl-style-spec/util/ref_properties.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@mapbox/mapbox-gl-style-spec/util/ref_properties.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nmodule.exports = ['type', 'source', 'source-layer', 'minzoom', 'maxzoom', 'filter', 'layout'];\n\n//# sourceURL=webpack://olms/./node_modules/@mapbox/mapbox-gl-style-spec/util/ref_properties.js?");

/***/ }),

/***/ "./node_modules/csscolorparser/csscolorparser.js":
/*!*******************************************************!*\
  !*** ./node_modules/csscolorparser/csscolorparser.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n// (c) Dean McNamee <dean@gmail.com>, 2012.\n//\n// https://github.com/deanm/css-color-parser-js\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to\n// deal in the Software without restriction, including without limitation the\n// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n// sell copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n// IN THE SOFTWARE.\n\n// http://www.w3.org/TR/css3-color/\nvar kCSSColorTable = {\n  \"transparent\": [0, 0, 0, 0], \"aliceblue\": [240, 248, 255, 1],\n  \"antiquewhite\": [250, 235, 215, 1], \"aqua\": [0, 255, 255, 1],\n  \"aquamarine\": [127, 255, 212, 1], \"azure\": [240, 255, 255, 1],\n  \"beige\": [245, 245, 220, 1], \"bisque\": [255, 228, 196, 1],\n  \"black\": [0, 0, 0, 1], \"blanchedalmond\": [255, 235, 205, 1],\n  \"blue\": [0, 0, 255, 1], \"blueviolet\": [138, 43, 226, 1],\n  \"brown\": [165, 42, 42, 1], \"burlywood\": [222, 184, 135, 1],\n  \"cadetblue\": [95, 158, 160, 1], \"chartreuse\": [127, 255, 0, 1],\n  \"chocolate\": [210, 105, 30, 1], \"coral\": [255, 127, 80, 1],\n  \"cornflowerblue\": [100, 149, 237, 1], \"cornsilk\": [255, 248, 220, 1],\n  \"crimson\": [220, 20, 60, 1], \"cyan\": [0, 255, 255, 1],\n  \"darkblue\": [0, 0, 139, 1], \"darkcyan\": [0, 139, 139, 1],\n  \"darkgoldenrod\": [184, 134, 11, 1], \"darkgray\": [169, 169, 169, 1],\n  \"darkgreen\": [0, 100, 0, 1], \"darkgrey\": [169, 169, 169, 1],\n  \"darkkhaki\": [189, 183, 107, 1], \"darkmagenta\": [139, 0, 139, 1],\n  \"darkolivegreen\": [85, 107, 47, 1], \"darkorange\": [255, 140, 0, 1],\n  \"darkorchid\": [153, 50, 204, 1], \"darkred\": [139, 0, 0, 1],\n  \"darksalmon\": [233, 150, 122, 1], \"darkseagreen\": [143, 188, 143, 1],\n  \"darkslateblue\": [72, 61, 139, 1], \"darkslategray\": [47, 79, 79, 1],\n  \"darkslategrey\": [47, 79, 79, 1], \"darkturquoise\": [0, 206, 209, 1],\n  \"darkviolet\": [148, 0, 211, 1], \"deeppink\": [255, 20, 147, 1],\n  \"deepskyblue\": [0, 191, 255, 1], \"dimgray\": [105, 105, 105, 1],\n  \"dimgrey\": [105, 105, 105, 1], \"dodgerblue\": [30, 144, 255, 1],\n  \"firebrick\": [178, 34, 34, 1], \"floralwhite\": [255, 250, 240, 1],\n  \"forestgreen\": [34, 139, 34, 1], \"fuchsia\": [255, 0, 255, 1],\n  \"gainsboro\": [220, 220, 220, 1], \"ghostwhite\": [248, 248, 255, 1],\n  \"gold\": [255, 215, 0, 1], \"goldenrod\": [218, 165, 32, 1],\n  \"gray\": [128, 128, 128, 1], \"green\": [0, 128, 0, 1],\n  \"greenyellow\": [173, 255, 47, 1], \"grey\": [128, 128, 128, 1],\n  \"honeydew\": [240, 255, 240, 1], \"hotpink\": [255, 105, 180, 1],\n  \"indianred\": [205, 92, 92, 1], \"indigo\": [75, 0, 130, 1],\n  \"ivory\": [255, 255, 240, 1], \"khaki\": [240, 230, 140, 1],\n  \"lavender\": [230, 230, 250, 1], \"lavenderblush\": [255, 240, 245, 1],\n  \"lawngreen\": [124, 252, 0, 1], \"lemonchiffon\": [255, 250, 205, 1],\n  \"lightblue\": [173, 216, 230, 1], \"lightcoral\": [240, 128, 128, 1],\n  \"lightcyan\": [224, 255, 255, 1], \"lightgoldenrodyellow\": [250, 250, 210, 1],\n  \"lightgray\": [211, 211, 211, 1], \"lightgreen\": [144, 238, 144, 1],\n  \"lightgrey\": [211, 211, 211, 1], \"lightpink\": [255, 182, 193, 1],\n  \"lightsalmon\": [255, 160, 122, 1], \"lightseagreen\": [32, 178, 170, 1],\n  \"lightskyblue\": [135, 206, 250, 1], \"lightslategray\": [119, 136, 153, 1],\n  \"lightslategrey\": [119, 136, 153, 1], \"lightsteelblue\": [176, 196, 222, 1],\n  \"lightyellow\": [255, 255, 224, 1], \"lime\": [0, 255, 0, 1],\n  \"limegreen\": [50, 205, 50, 1], \"linen\": [250, 240, 230, 1],\n  \"magenta\": [255, 0, 255, 1], \"maroon\": [128, 0, 0, 1],\n  \"mediumaquamarine\": [102, 205, 170, 1], \"mediumblue\": [0, 0, 205, 1],\n  \"mediumorchid\": [186, 85, 211, 1], \"mediumpurple\": [147, 112, 219, 1],\n  \"mediumseagreen\": [60, 179, 113, 1], \"mediumslateblue\": [123, 104, 238, 1],\n  \"mediumspringgreen\": [0, 250, 154, 1], \"mediumturquoise\": [72, 209, 204, 1],\n  \"mediumvioletred\": [199, 21, 133, 1], \"midnightblue\": [25, 25, 112, 1],\n  \"mintcream\": [245, 255, 250, 1], \"mistyrose\": [255, 228, 225, 1],\n  \"moccasin\": [255, 228, 181, 1], \"navajowhite\": [255, 222, 173, 1],\n  \"navy\": [0, 0, 128, 1], \"oldlace\": [253, 245, 230, 1],\n  \"olive\": [128, 128, 0, 1], \"olivedrab\": [107, 142, 35, 1],\n  \"orange\": [255, 165, 0, 1], \"orangered\": [255, 69, 0, 1],\n  \"orchid\": [218, 112, 214, 1], \"palegoldenrod\": [238, 232, 170, 1],\n  \"palegreen\": [152, 251, 152, 1], \"paleturquoise\": [175, 238, 238, 1],\n  \"palevioletred\": [219, 112, 147, 1], \"papayawhip\": [255, 239, 213, 1],\n  \"peachpuff\": [255, 218, 185, 1], \"peru\": [205, 133, 63, 1],\n  \"pink\": [255, 192, 203, 1], \"plum\": [221, 160, 221, 1],\n  \"powderblue\": [176, 224, 230, 1], \"purple\": [128, 0, 128, 1],\n  \"rebeccapurple\": [102, 51, 153, 1],\n  \"red\": [255, 0, 0, 1], \"rosybrown\": [188, 143, 143, 1],\n  \"royalblue\": [65, 105, 225, 1], \"saddlebrown\": [139, 69, 19, 1],\n  \"salmon\": [250, 128, 114, 1], \"sandybrown\": [244, 164, 96, 1],\n  \"seagreen\": [46, 139, 87, 1], \"seashell\": [255, 245, 238, 1],\n  \"sienna\": [160, 82, 45, 1], \"silver\": [192, 192, 192, 1],\n  \"skyblue\": [135, 206, 235, 1], \"slateblue\": [106, 90, 205, 1],\n  \"slategray\": [112, 128, 144, 1], \"slategrey\": [112, 128, 144, 1],\n  \"snow\": [255, 250, 250, 1], \"springgreen\": [0, 255, 127, 1],\n  \"steelblue\": [70, 130, 180, 1], \"tan\": [210, 180, 140, 1],\n  \"teal\": [0, 128, 128, 1], \"thistle\": [216, 191, 216, 1],\n  \"tomato\": [255, 99, 71, 1], \"turquoise\": [64, 224, 208, 1],\n  \"violet\": [238, 130, 238, 1], \"wheat\": [245, 222, 179, 1],\n  \"white\": [255, 255, 255, 1], \"whitesmoke\": [245, 245, 245, 1],\n  \"yellow\": [255, 255, 0, 1], \"yellowgreen\": [154, 205, 50, 1] };\n\nfunction clamp_css_byte(i) {\n  // Clamp to integer 0 .. 255.\n  i = Math.round(i); // Seems to be what Chrome does (vs truncation).\n  return i < 0 ? 0 : i > 255 ? 255 : i;\n}\n\nfunction clamp_css_float(f) {\n  // Clamp to float 0.0 .. 1.0.\n  return f < 0 ? 0 : f > 1 ? 1 : f;\n}\n\nfunction parse_css_int(str) {\n  // int or percentage.\n  if (str[str.length - 1] === '%') return clamp_css_byte(parseFloat(str) / 100 * 255);\n  return clamp_css_byte(parseInt(str));\n}\n\nfunction parse_css_float(str) {\n  // float or percentage.\n  if (str[str.length - 1] === '%') return clamp_css_float(parseFloat(str) / 100);\n  return clamp_css_float(parseFloat(str));\n}\n\nfunction css_hue_to_rgb(m1, m2, h) {\n  if (h < 0) h += 1;else if (h > 1) h -= 1;\n\n  if (h * 6 < 1) return m1 + (m2 - m1) * h * 6;\n  if (h * 2 < 1) return m2;\n  if (h * 3 < 2) return m1 + (m2 - m1) * (2 / 3 - h) * 6;\n  return m1;\n}\n\nfunction parseCSSColor(css_str) {\n  // Remove all whitespace, not compliant, but should just be more accepting.\n  var str = css_str.replace(/ /g, '').toLowerCase();\n\n  // Color keywords (and transparent) lookup.\n  if (str in kCSSColorTable) return kCSSColorTable[str].slice(); // dup.\n\n  // #abc and #abc123 syntax.\n  if (str[0] === '#') {\n    if (str.length === 4) {\n      var iv = parseInt(str.substr(1), 16); // TODO(deanm): Stricter parsing.\n      if (!(iv >= 0 && iv <= 0xfff)) return null; // Covers NaN.\n      return [(iv & 0xf00) >> 4 | (iv & 0xf00) >> 8, iv & 0xf0 | (iv & 0xf0) >> 4, iv & 0xf | (iv & 0xf) << 4, 1];\n    } else if (str.length === 7) {\n      var iv = parseInt(str.substr(1), 16); // TODO(deanm): Stricter parsing.\n      if (!(iv >= 0 && iv <= 0xffffff)) return null; // Covers NaN.\n      return [(iv & 0xff0000) >> 16, (iv & 0xff00) >> 8, iv & 0xff, 1];\n    }\n\n    return null;\n  }\n\n  var op = str.indexOf('('),\n      ep = str.indexOf(')');\n  if (op !== -1 && ep + 1 === str.length) {\n    var fname = str.substr(0, op);\n    var params = str.substr(op + 1, ep - (op + 1)).split(',');\n    var alpha = 1; // To allow case fallthrough.\n    switch (fname) {\n      case 'rgba':\n        if (params.length !== 4) return null;\n        alpha = parse_css_float(params.pop());\n      // Fall through.\n      case 'rgb':\n        if (params.length !== 3) return null;\n        return [parse_css_int(params[0]), parse_css_int(params[1]), parse_css_int(params[2]), alpha];\n      case 'hsla':\n        if (params.length !== 4) return null;\n        alpha = parse_css_float(params.pop());\n      // Fall through.\n      case 'hsl':\n        if (params.length !== 3) return null;\n        var h = (parseFloat(params[0]) % 360 + 360) % 360 / 360; // 0 .. 1\n        // NOTE(deanm): According to the CSS spec s/l should only be\n        // percentages, but we don't bother and let float or percentage.\n        var s = parse_css_float(params[1]);\n        var l = parse_css_float(params[2]);\n        var m2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;\n        var m1 = l * 2 - m2;\n        return [clamp_css_byte(css_hue_to_rgb(m1, m2, h + 1 / 3) * 255), clamp_css_byte(css_hue_to_rgb(m1, m2, h) * 255), clamp_css_byte(css_hue_to_rgb(m1, m2, h - 1 / 3) * 255), alpha];\n      default:\n        return null;\n    }\n  }\n\n  return null;\n}\n\ntry {\n  exports.parseCSSColor = parseCSSColor;\n} catch (e) {}\n\n//# sourceURL=webpack://olms/./node_modules/csscolorparser/csscolorparser.js?");

/***/ }),

/***/ "./node_modules/mapbox-to-css-font/index.js":
/*!**************************************************!*\
  !*** ./node_modules/mapbox-to-css-font/index.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar fontWeights = {\n  thin: 100,\n  hairline: 100,\n  'ultra-light': 100,\n  'extra-light': 100,\n  light: 200,\n  book: 300,\n  regular: 400,\n  normal: 400,\n  plain: 400,\n  roman: 400,\n  standard: 400,\n  medium: 500,\n  'semi-bold': 600,\n  'demi-bold': 600,\n  bold: 700,\n  heavy: 800,\n  black: 800,\n  'extra-bold': 800,\n  'ultra-black': 900,\n  'extra-black': 900,\n  'ultra-bold': 900,\n  'heavy-black': 900,\n  fat: 900,\n  poster: 900\n};\nvar sp = ' ';\n\nvar fontCache = {};\n\nmodule.exports = function (font, size) {\n  var cssData = fontCache[font];\n  if (!cssData) {\n    var parts = font.split(' ');\n    var maybeWeight = parts[parts.length - 1].toLowerCase();\n    var weight = 'normal';\n    var style = 'normal';\n    if (maybeWeight == 'normal' || maybeWeight == 'italic' || maybeWeight == 'oblique') {\n      style = maybeWeight;\n      parts.pop();\n      maybeWeight = parts[parts.length - 1].toLowerCase();\n    }\n    for (var w in fontWeights) {\n      if (maybeWeight == w || maybeWeight == w.replace('-', '') || maybeWeight == w.replace('-', ' ')) {\n        weight = fontWeights[w];\n        parts.pop();\n        break;\n      }\n    }\n    if (typeof maybeWeight == 'number') {\n      weight = maybeWeight;\n    }\n    var fontFamily = parts.join(' ').replace('Klokantech Noto Sans', 'Noto Sans');\n    if (fontFamily.indexOf(' ') !== -1) {\n      fontFamily = '\"' + fontFamily + '\"';\n    }\n    // CSS font property: font-style font-weight font-size font-family\n    cssData = fontCache[font] = [style, weight, fontFamily];\n  }\n  return cssData[0] + sp + cssData[1] + sp + size + 'px' + sp + cssData[2];\n};\n\n//# sourceURL=webpack://olms/./node_modules/mapbox-to-css-font/index.js?");

/***/ }),

/***/ "./node_modules/webfont-matcher/lib/fonts/google.js":
/*!**********************************************************!*\
  !*** ./node_modules/webfont-matcher/lib/fonts/google.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n// Generated by CoffeeScript 1.10.0\n(function () {\n  var families;\n\n  module.exports = {\n    icon: 'icons/google.svg',\n    name: 'google',\n    title: 'Google Fonts',\n    link: 'google.com/fonts',\n    getNames: function getNames() {\n      return families;\n    },\n    getLink: function getLink(name) {\n      return \"https://fonts.google.com/specimen/\" + name.replace(/( )/g, '+');\n    },\n    normalizeName: function normalizeName(name) {\n      return name;\n    }\n  };\n\n  families = [\"ABeeZee\", \"Abel\", \"Abril Fatface\", \"Aclonica\", \"Acme\", \"Actor\", \"Adamina\", \"Advent Pro\", \"Aguafina Script\", \"Akronim\", \"Aladin\", \"Aldrich\", \"Alef\", \"Alegreya\", \"Alegreya SC\", \"Alegreya Sans\", \"Alegreya Sans SC\", \"Alex Brush\", \"Alfa Slab One\", \"Alice\", \"Alike\", \"Alike Angular\", \"Allan\", \"Allerta\", \"Allerta Stencil\", \"Allura\", \"Almendra\", \"Almendra Display\", \"Almendra SC\", \"Amarante\", \"Amaranth\", \"Amatic SC\", \"Amethysta\", \"Amiri\", \"Amita\", \"Anaheim\", \"Andada\", \"Andika\", \"Angkor\", \"Annie Use Your Telescope\", \"Anonymous Pro\", \"Antic\", \"Antic Didone\", \"Antic Slab\", \"Anton\", \"Arapey\", \"Arbutus\", \"Arbutus Slab\", \"Architects Daughter\", \"Archivo Black\", \"Archivo Narrow\", \"Arimo\", \"Arizonia\", \"Armata\", \"Artifika\", \"Arvo\", \"Arya\", \"Asap\", \"Asar\", \"Asset\", \"Astloch\", \"Asul\", \"Atomic Age\", \"Aubrey\", \"Audiowide\", \"Autour One\", \"Average\", \"Average Sans\", \"Averia Gruesa Libre\", \"Averia Libre\", \"Averia Sans Libre\", \"Averia Serif Libre\", \"Bad Script\", \"Balthazar\", \"Bangers\", \"Basic\", \"Battambang\", \"Baumans\", \"Bayon\", \"Belgrano\", \"Belleza\", \"BenchNine\", \"Bentham\", \"Berkshire Swash\", \"Bevan\", \"Bigelow Rules\", \"Bigshot One\", \"Bilbo\", \"Bilbo Swash Caps\", \"Biryani\", \"Bitter\", \"Black Ops One\", \"Bokor\", \"Bonbon\", \"Boogaloo\", \"Bowlby One\", \"Bowlby One SC\", \"Brawler\", \"Bree Serif\", \"Bubblegum Sans\", \"Bubbler One\", \"Buda\", \"Buenard\", \"Butcherman\", \"Butterfly Kids\", \"Cabin\", \"Cabin Condensed\", \"Cabin Sketch\", \"Caesar Dressing\", \"Cagliostro\", \"Calligraffitti\", \"Cambay\", \"Cambo\", \"Candal\", \"Cantarell\", \"Cantata One\", \"Cantora One\", \"Capriola\", \"Cardo\", \"Carme\", \"Carrois Gothic\", \"Carrois Gothic SC\", \"Carter One\", \"Catamaran\", \"Caudex\", \"Caveat\", \"Caveat Brush\", \"Cedarville Cursive\", \"Ceviche One\", \"Changa One\", \"Chango\", \"Chau Philomene One\", \"Chela One\", \"Chelsea Market\", \"Chenla\", \"Cherry Cream Soda\", \"Cherry Swash\", \"Chewy\", \"Chicle\", \"Chivo\", \"Chonburi\", \"Cinzel\", \"Cinzel Decorative\", \"Clicker Script\", \"Coda\", \"Coda Caption\", \"Codystar\", \"Combo\", \"Comfortaa\", \"Coming Soon\", \"Concert One\", \"Condiment\", \"Content\", \"Contrail One\", \"Convergence\", \"Cookie\", \"Copse\", \"Corben\", \"Courgette\", \"Cousine\", \"Coustard\", \"Covered By Your Grace\", \"Crafty Girls\", \"Creepster\", \"Crete Round\", \"Crimson Text\", \"Croissant One\", \"Crushed\", \"Cuprum\", \"Cutive\", \"Cutive Mono\", \"Damion\", \"Dancing Script\", \"Dangrek\", \"Dawning of a New Day\", \"Days One\", \"Dekko\", \"Delius\", \"Delius Swash Caps\", \"Delius Unicase\", \"Della Respira\", \"Denk One\", \"Devonshire\", \"Dhurjati\", \"Didact Gothic\", \"Diplomata\", \"Diplomata SC\", \"Domine\", \"Donegal One\", \"Doppio One\", \"Dorsa\", \"Dosis\", \"Dr Sugiyama\", \"Droid Sans\", \"Droid Sans Mono\", \"Droid Serif\", \"Duru Sans\", \"Dynalight\", \"EB Garamond\", \"Eagle Lake\", \"Eater\", \"Economica\", \"Eczar\", \"Ek Mukta\", \"Electrolize\", \"Elsie\", \"Elsie Swash Caps\", \"Emblema One\", \"Emilys Candy\", \"Engagement\", \"Englebert\", \"Enriqueta\", \"Erica One\", \"Esteban\", \"Euphoria Script\", \"Ewert\", \"Exo\", \"Exo 2\", \"Expletus Sans\", \"Fanwood Text\", \"Fascinate\", \"Fascinate Inline\", \"Faster One\", \"Fasthand\", \"Fauna One\", \"Federant\", \"Federo\", \"Felipa\", \"Fenix\", \"Finger Paint\", \"Fira Mono\", \"Fira Sans\", \"Fjalla One\", \"Fjord One\", \"Flamenco\", \"Flavors\", \"Fondamento\", \"Fontdiner Swanky\", \"Forum\", \"Francois One\", \"Freckle Face\", \"Fredericka the Great\", \"Fredoka One\", \"Freehand\", \"Fresca\", \"Frijole\", \"Fruktur\", \"Fugaz One\", \"GFS Didot\", \"GFS Neohellenic\", \"Gabriela\", \"Gafata\", \"Galdeano\", \"Galindo\", \"Gentium Basic\", \"Gentium Book Basic\", \"Geo\", \"Geostar\", \"Geostar Fill\", \"Germania One\", \"Gidugu\", \"Gilda Display\", \"Give You Glory\", \"Glass Antiqua\", \"Glegoo\", \"Gloria Hallelujah\", \"Goblin One\", \"Gochi Hand\", \"Gorditas\", \"Goudy Bookletter 1911\", \"Graduate\", \"Grand Hotel\", \"Gravitas One\", \"Great Vibes\", \"Griffy\", \"Gruppo\", \"Gudea\", \"Gurajada\", \"Habibi\", \"Halant\", \"Hammersmith One\", \"Hanalei\", \"Hanalei Fill\", \"Handlee\", \"Hanuman\", \"Happy Monkey\", \"Headland One\", \"Henny Penny\", \"Herr Von Muellerhoff\", \"Hind\", \"Hind Siliguri\", \"Hind Vadodara\", \"Holtwood One SC\", \"Homemade Apple\", \"Homenaje\", \"IM Fell DW Pica\", \"IM Fell DW Pica SC\", \"IM Fell Double Pica\", \"IM Fell Double Pica SC\", \"IM Fell English\", \"IM Fell English SC\", \"IM Fell French Canon\", \"IM Fell French Canon SC\", \"IM Fell Great Primer\", \"IM Fell Great Primer SC\", \"Iceberg\", \"Iceland\", \"Imprima\", \"Inconsolata\", \"Inder\", \"Indie Flower\", \"Inika\", \"Inknut Antiqua\", \"Irish Grover\", \"Istok Web\", \"Italiana\", \"Italianno\", \"Itim\", \"Jacques Francois\", \"Jacques Francois Shadow\", \"Jaldi\", \"Jim Nightshade\", \"Jockey One\", \"Jolly Lodger\", \"Josefin Sans\", \"Josefin Slab\", \"Joti One\", \"Judson\", \"Julee\", \"Julius Sans One\", \"Junge\", \"Jura\", \"Just Another Hand\", \"Just Me Again Down Here\", \"Kadwa\", \"Kalam\", \"Kameron\", \"Kantumruy\", \"Karla\", \"Karma\", \"Kaushan Script\", \"Kavoon\", \"Kdam Thmor\", \"Keania One\", \"Kelly Slab\", \"Kenia\", \"Khand\", \"Khmer\", \"Khula\", \"Kite One\", \"Knewave\", \"Kotta One\", \"Koulen\", \"Kranky\", \"Kreon\", \"Kristi\", \"Krona One\", \"Kurale\", \"La Belle Aurore\", \"Laila\", \"Lakki Reddy\", \"Lancelot\", \"Lateef\", \"Lato\", \"League Script\", \"Leckerli One\", \"Ledger\", \"Lekton\", \"Lemon\", \"Libre Baskerville\", \"Life Savers\", \"Lilita One\", \"Lily Script One\", \"Limelight\", \"Linden Hill\", \"Lobster\", \"Lobster Two\", \"Londrina Outline\", \"Londrina Shadow\", \"Londrina Sketch\", \"Londrina Solid\", \"Lora\", \"Love Ya Like A Sister\", \"Loved by the King\", \"Lovers Quarrel\", \"Luckiest Guy\", \"Lusitana\", \"Lustria\", \"Macondo\", \"Macondo Swash Caps\", \"Magra\", \"Maiden Orange\", \"Mako\", \"Mallanna\", \"Mandali\", \"Marcellus\", \"Marcellus SC\", \"Marck Script\", \"Margarine\", \"Marko One\", \"Marmelad\", \"Martel\", \"Martel Sans\", \"Marvel\", \"Mate\", \"Mate SC\", \"Maven Pro\", \"McLaren\", \"Meddon\", \"MedievalSharp\", \"Medula One\", \"Megrim\", \"Meie Script\", \"Merienda\", \"Merienda One\", \"Merriweather\", \"Merriweather Sans\", \"Metal\", \"Metal Mania\", \"Metamorphous\", \"Metrophobic\", \"Michroma\", \"Milonga\", \"Miltonian\", \"Miltonian Tattoo\", \"Miniver\", \"Miss Fajardose\", \"Modak\", \"Modern Antiqua\", \"Molengo\", \"Molle\", \"Monda\", \"Monofett\", \"Monoton\", \"Monsieur La Doulaise\", \"Montaga\", \"Montez\", \"Montserrat\", \"Montserrat Alternates\", \"Montserrat Subrayada\", \"Moul\", \"Moulpali\", \"Mountains of Christmas\", \"Mouse Memoirs\", \"Mr Bedfort\", \"Mr Dafoe\", \"Mr De Haviland\", \"Mrs Saint Delafield\", \"Mrs Sheppards\", \"Muli\", \"Mystery Quest\", \"NTR\", \"Neucha\", \"Neuton\", \"New Rocker\", \"News Cycle\", \"Niconne\", \"Nixie One\", \"Nobile\", \"Nokora\", \"Norican\", \"Nosifer\", \"Nothing You Could Do\", \"Noticia Text\", \"Noto Sans\", \"Noto Serif\", \"Nova Cut\", \"Nova Flat\", \"Nova Mono\", \"Nova Oval\", \"Nova Round\", \"Nova Script\", \"Nova Slim\", \"Nova Square\", \"Numans\", \"Nunito\", \"Odor Mean Chey\", \"Offside\", \"Old Standard TT\", \"Oldenburg\", \"Oleo Script\", \"Oleo Script Swash Caps\", \"Open Sans\", \"Open Sans Condensed\", \"Oranienbaum\", \"Orbitron\", \"Oregano\", \"Orienta\", \"Original Surfer\", \"Oswald\", \"Over the Rainbow\", \"Overlock\", \"Overlock SC\", \"Ovo\", \"Oxygen\", \"Oxygen Mono\", \"PT Mono\", \"PT Sans\", \"PT Sans Caption\", \"PT Sans Narrow\", \"PT Serif\", \"PT Serif Caption\", \"Pacifico\", \"Palanquin\", \"Palanquin Dark\", \"Paprika\", \"Parisienne\", \"Passero One\", \"Passion One\", \"Pathway Gothic One\", \"Patrick Hand\", \"Patrick Hand SC\", \"Patua One\", \"Paytone One\", \"Peddana\", \"Peralta\", \"Permanent Marker\", \"Petit Formal Script\", \"Petrona\", \"Philosopher\", \"Piedra\", \"Pinyon Script\", \"Pirata One\", \"Plaster\", \"Play\", \"Playball\", \"Playfair Display\", \"Playfair Display SC\", \"Podkova\", \"Poiret One\", \"Poller One\", \"Poly\", \"Pompiere\", \"Pontano Sans\", \"Poppins\", \"Port Lligat Sans\", \"Port Lligat Slab\", \"Pragati Narrow\", \"Prata\", \"Preahvihear\", \"Press Start 2P\", \"Princess Sofia\", \"Prociono\", \"Prosto One\", \"Puritan\", \"Purple Purse\", \"Quando\", \"Quantico\", \"Quattrocento\", \"Quattrocento Sans\", \"Questrial\", \"Quicksand\", \"Quintessential\", \"Qwigley\", \"Racing Sans One\", \"Radley\", \"Rajdhani\", \"Raleway\", \"Raleway Dots\", \"Ramabhadra\", \"Ramaraja\", \"Rambla\", \"Rammetto One\", \"Ranchers\", \"Rancho\", \"Ranga\", \"Rationale\", \"Ravi Prakash\", \"Redressed\", \"Reenie Beanie\", \"Revalia\", \"Rhodium Libre\", \"Ribeye\", \"Ribeye Marrow\", \"Righteous\", \"Risque\", \"Roboto\", \"Roboto Condensed\", \"Roboto Mono\", \"Roboto Slab\", \"Rochester\", \"Rock Salt\", \"Rokkitt\", \"Romanesco\", \"Ropa Sans\", \"Rosario\", \"Rosarivo\", \"Rouge Script\", \"Rozha One\", \"Rubik\", \"Rubik Mono One\", \"Rubik One\", \"Ruda\", \"Rufina\", \"Ruge Boogie\", \"Ruluko\", \"Rum Raisin\", \"Ruslan Display\", \"Russo One\", \"Ruthie\", \"Rye\", \"Sacramento\", \"Sahitya\", \"Sail\", \"Salsa\", \"Sanchez\", \"Sancreek\", \"Sansita One\", \"Sarala\", \"Sarina\", \"Sarpanch\", \"Satisfy\", \"Scada\", \"Scheherazade\", \"Schoolbell\", \"Seaweed Script\", \"Sevillana\", \"Seymour One\", \"Shadows Into Light\", \"Shadows Into Light Two\", \"Shanti\", \"Share\", \"Share Tech\", \"Share Tech Mono\", \"Shojumaru\", \"Short Stack\", \"Siemreap\", \"Sigmar One\", \"Signika\", \"Signika Negative\", \"Simonetta\", \"Sintony\", \"Sirin Stencil\", \"Six Caps\", \"Skranji\", \"Slabo 13px\", \"Slabo 27px\", \"Slackey\", \"Smokum\", \"Smythe\", \"Sniglet\", \"Snippet\", \"Snowburst One\", \"Sofadi One\", \"Sofia\", \"Sonsie One\", \"Sorts Mill Goudy\", \"Source Code Pro\", \"Source Sans Pro\", \"Source Serif Pro\", \"Special Elite\", \"Spicy Rice\", \"Spinnaker\", \"Spirax\", \"Squada One\", \"Sree Krushnadevaraya\", \"Stalemate\", \"Stalinist One\", \"Stardos Stencil\", \"Stint Ultra Condensed\", \"Stint Ultra Expanded\", \"Stoke\", \"Strait\", \"Sue Ellen Francisco\", \"Sumana\", \"Sunshiney\", \"Supermercado One\", \"Sura\", \"Suranna\", \"Suravaram\", \"Suwannaphum\", \"Swanky and Moo Moo\", \"Syncopate\", \"Tangerine\", \"Taprom\", \"Tauri\", \"Teko\", \"Telex\", \"Tenali Ramakrishna\", \"Tenor Sans\", \"Text Me One\", \"The Girl Next Door\", \"Tienne\", \"Tillana\", \"Timmana\", \"Tinos\", \"Titan One\", \"Titillium Web\", \"Trade Winds\", \"Trocchi\", \"Trochut\", \"Trykker\", \"Tulpen One\", \"Ubuntu\", \"Ubuntu Condensed\", \"Ubuntu Mono\", \"Ultra\", \"Uncial Antiqua\", \"Underdog\", \"Unica One\", \"UnifrakturCook\", \"UnifrakturMaguntia\", \"Unkempt\", \"Unlock\", \"Unna\", \"VT323\", \"Vampiro One\", \"Varela\", \"Varela Round\", \"Vast Shadow\", \"Vesper Libre\", \"Vibur\", \"Vidaloka\", \"Viga\", \"Voces\", \"Volkhov\", \"Vollkorn\", \"Voltaire\", \"Waiting for the Sunrise\", \"Wallpoet\", \"Walter Turncoat\", \"Warnes\", \"Wellfleet\", \"Wendy One\", \"Wire One\", \"Work Sans\", \"Yanone Kaffeesatz\", \"Yantramanav\", \"Yellowtail\", \"Yeseva One\", \"Yesteryear\", \"Zeyada\"];\n}).call(undefined);\n\n//# sourceURL=webpack://olms/./node_modules/webfont-matcher/lib/fonts/google.js?");

/***/ }),

/***/ "./olms.js":
/*!*****************!*\
  !*** ./olms.js ***!
  \*****************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _index = __webpack_require__(/*! ./index */ \"./index.js\");\n\nvar _stylefunction = __webpack_require__(/*! ./stylefunction */ \"./stylefunction.js\");\n\nvar _stylefunction2 = _interopRequireDefault(_stylefunction);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = {\n  apply: _index.apply,\n  applyBackground: _index.applyBackground,\n  applyStyle: _index.applyStyle,\n  stylefunction: _stylefunction2.default\n};\n\n//# sourceURL=webpack://olms/./olms.js?");

/***/ }),

/***/ "./stylefunction.js":
/*!**************************!*\
  !*** ./stylefunction.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; /*\r\n                                                                                                                                                                                                                                                                              ol-mapbox-style - Use Mapbox Style objects with OpenLayers\r\n                                                                                                                                                                                                                                                                              Copyright 2016-present Boundless Spatial, Inc.\r\n                                                                                                                                                                                                                                                                              License: https://raw.githubusercontent.com/boundlessgeo/ol-mapbox-gl-style/master/LICENSE\r\n                                                                                                                                                                                                                                                                              */\n\nexports.default = function (olLayer, glStyle, source, resolutions, spriteData, spriteImageUrl, fonts) {\n  if (!resolutions) {\n    resolutions = [];\n    for (var res = 78271.51696402048; resolutions.length < 21; res /= 2) {\n      resolutions.push(res);\n    }\n  }\n  if (typeof glStyle == 'string') {\n    glStyle = JSON.parse(glStyle);\n  }\n  if (glStyle.version != 8) {\n    throw new Error('glStyle version 8 required.');\n  }\n\n  var spriteImage = void 0,\n      spriteImgSize = void 0;\n  if (spriteImageUrl) {\n    var img = new Image();\n    img.crossOrigin = 'anonymous';\n    img.onload = function () {\n      spriteImage = img;\n      spriteImgSize = [img.width, img.height];\n      olLayer.changed();\n    };\n    img.src = spriteImageUrl;\n  }\n\n  var ctx = document.createElement('CANVAS').getContext('2d');\n  var measureCache = {};\n\n  function wrapText(text, font, em) {\n    var key = em + ',' + font + ',' + text;\n    var wrappedText = measureCache[key];\n    if (!wrappedText) {\n      ctx.font = font;\n      var oneEm = ctx.measureText('M').width;\n      var width = oneEm * em;\n      var words = text.split(' ');\n      var line = '';\n      var lines = [];\n      for (var i = 0, ii = words.length; i < ii; ++i) {\n        var word = words[i];\n        if (ctx.measureText(line + word).width <= width) {\n          line += (line ? ' ' : '') + word;\n        } else {\n          if (line) {\n            lines.push(line);\n          }\n          line = word;\n        }\n      }\n      if (line) {\n        lines.push(line);\n      }\n      measureCache[key] = wrappedText = lines.join('\\n');\n    }\n    return wrappedText;\n  }\n\n  var allLayers = (0, _deref2.default)(glStyle.layers);\n\n  var layersBySourceLayer = {};\n  var mapboxLayers = [];\n  var mapboxSource = void 0;\n  for (var i = 0, ii = allLayers.length; i < ii; ++i) {\n    var layer = allLayers[i];\n    var layerId = layer.id;\n    if (typeof source == 'string' && layer.source == source || source.indexOf(layerId) !== -1) {\n      var sourceLayer = layer['source-layer'];\n      if (!mapboxSource) {\n        mapboxSource = layer.source;\n      }\n      var layers = layersBySourceLayer[sourceLayer];\n      if (!layers) {\n        layers = layersBySourceLayer[sourceLayer] = [];\n      }\n      layers.push({\n        layer: layer,\n        index: i\n      });\n      mapboxLayers.push(layerId);\n    }\n    // // TODO revisit when diffing gets added\n    delete functionCache[layerId];\n    delete filterCache[layerId];\n  }\n  var iconImageCache = {};\n\n  var styles = [];\n  var patternCache = {};\n\n  var styleFunction = function styleFunction(feature, resolution) {\n    var properties = feature.getProperties();\n    feature.styleIds = feature.styleIds || {};\n    var layers = layersBySourceLayer[properties.layer];\n    if (!layers) {\n      return;\n    }\n    var zoom = resolutions.indexOf(resolution);\n    if (zoom == -1) {\n      zoom = Math.round((0, _util.getZoomForResolution)(resolution, resolutions));\n    }\n    var type = types[feature.getGeometry().getType()];\n    var f = {\n      properties: properties,\n      type: type\n    };\n    var stylesLength = -1;\n    for (var _i = 0, _ii = layers.length; _i < _ii; ++_i) {\n      var layerData = layers[_i];\n      var _layer = layerData.layer;\n      var _layerId = _layer.id;\n\n      var layout = _layer.layout || emptyObj;\n      var paint = _layer.paint || emptyObj;\n      if (layout.visibility === 'none' || 'minzoom' in _layer && zoom < _layer.minzoom || 'maxzoom' in _layer && zoom >= _layer.maxzoom) {\n        continue;\n      }\n      feature.styleIds[zoom] = feature.styleIds[zoom] || [];\n      var filter = _layer.filter;\n      var icon = void 0,\n          iconImg = void 0;\n      if (!filter || evaluateFilter(_layerId, filter, f)) {\n        var color = void 0,\n            opacity = void 0,\n            fill = void 0,\n            stroke = void 0,\n            strokeColor = void 0,\n            style = void 0;\n        var index = layerData.index;\n        if (type == 3) {\n          if ('fill-pattern' in paint) {\n            var iconImage = getValue(_layerId, paint, 'fill-pattern', zoom, properties);\n            if (iconImage) {\n              icon = fromTemplate(iconImage, properties);\n              if (spriteImage && spriteData && spriteData[icon]) {\n                ++stylesLength;\n                if (feature.styleIds[zoom].indexOf(_layerId) === -1) {\n                  feature.styleIds[zoom].push(_layerId);\n                }\n                style = styles[stylesLength];\n                if (!style || !style.getFill() || style.getStroke() || style.getText()) {\n                  style = styles[stylesLength] = new _Style2.default({\n                    fill: new _Fill2.default()\n                  });\n                }\n                fill = style.getFill();\n                style.setZIndex(index);\n                var pattern = patternCache[icon];\n                if (!pattern) {\n                  var spriteImageData = spriteData[icon];\n                  var canvas = document.createElement('canvas');\n                  canvas.width = spriteImageData.width;\n                  canvas.height = spriteImageData.height;\n                  var _ctx = canvas.getContext('2d');\n                  _ctx.drawImage(spriteImage, spriteImageData.x, spriteImageData.y, spriteImageData.width, spriteImageData.height, 0, 0, spriteImageData.width, spriteImageData.height);\n                  pattern = _ctx.createPattern(canvas, 'repeat');\n                  patternCache[icon] = pattern;\n                }\n                fill.setColor(pattern);\n              }\n            }\n          } else if ('fill-color' in paint) {\n            opacity = getValue(_layerId, paint, 'fill-opacity', zoom, properties);\n            color = colorWithOpacity(getValue(_layerId, paint, 'fill-color', zoom, properties), opacity);\n            if (color) {\n              ++stylesLength;\n              if (feature.styleIds[zoom].indexOf(_layerId) === -1) {\n                feature.styleIds[zoom].push(_layerId);\n              }\n              style = styles[stylesLength];\n              if (!style || !style.getFill() || style.getStroke() || style.getText()) {\n                style = styles[stylesLength] = new _Style2.default({\n                  fill: new _Fill2.default()\n                });\n              }\n              fill = style.getFill();\n              fill.setColor(color);\n              style.setZIndex(index);\n            }\n            if ('fill-outline-color' in paint) {\n              strokeColor = colorWithOpacity(getValue(_layerId, paint, 'fill-outline-color', zoom, properties), opacity);\n            } else if ('fill-antialias' in paint) {\n              strokeColor = color;\n            }\n            if (strokeColor) {\n              ++stylesLength;\n              if (feature.styleIds[zoom].indexOf(_layerId) === -1) {\n                feature.styleIds[zoom].push(_layerId);\n              }\n              style = styles[stylesLength];\n              if (!style || !style.getStroke() || style.getFill() || style.getText()) {\n                style = styles[stylesLength] = new _Style2.default({\n                  stroke: new _Stroke2.default()\n                });\n              }\n              stroke = style.getStroke();\n              stroke.setLineCap(defaults['line-cap']);\n              stroke.setLineJoin(defaults['line-join']);\n              stroke.setMiterLimit(defaults['line-miter-limit']);\n              stroke.setColor(strokeColor);\n              stroke.setWidth(1);\n              stroke.setLineDash(null);\n              style.setZIndex(index);\n            }\n          }\n        }\n        if (type != 1) {\n          (function () {\n            color = !('line-pattern' in paint) && 'line-color' in paint ? colorWithOpacity(getValue(_layerId, paint, 'line-color', zoom, properties), getValue(_layerId, paint, 'line-opacity', zoom, properties)) : undefined;\n            var width = getValue(_layerId, paint, 'line-width', zoom, properties);\n            if (color && width > 0) {\n              ++stylesLength;\n              if (feature.styleIds[zoom].indexOf(_layerId) === -1) {\n                feature.styleIds[zoom].push(_layerId);\n              }\n              style = styles[stylesLength];\n              if (!style || !style.getStroke() || style.getFill() || style.getText()) {\n                style = styles[stylesLength] = new _Style2.default({\n                  stroke: new _Stroke2.default()\n                });\n              }\n              stroke = style.getStroke();\n              stroke.setLineCap(getValue(_layerId, layout, 'line-cap', zoom, properties));\n              stroke.setLineJoin(getValue(_layerId, layout, 'line-join', zoom, properties));\n              stroke.setMiterLimit(getValue(_layerId, layout, 'line-miter-limit', zoom, properties));\n              stroke.setColor(color);\n              stroke.setWidth(width);\n              stroke.setLineDash(paint['line-dasharray'] ? getValue(_layerId, paint, 'line-dasharray', zoom, properties).map(function (x) {\n                return x * width;\n              }) : null);\n              style.setZIndex(index);\n            }\n          })();\n        }\n\n        var hasImage = false;\n        var text = null;\n        var skipLabel = void 0;\n        if ((type == 1 || type == 2) && 'icon-image' in layout) {\n          var _iconImage = getValue(_layerId, layout, 'icon-image', zoom, properties);\n          if (_iconImage) {\n            icon = fromTemplate(_iconImage, properties);\n            var styleGeom = undefined;\n            if (spriteImage && spriteData && spriteData[icon]) {\n              if (type == 2) {\n                var geom = feature.getGeometry();\n                // ol package and ol-debug.js only\n                if (geom.getFlatMidpoint) {\n                  var extent = geom.getExtent();\n                  var size = Math.sqrt(Math.max(Math.pow((extent[2] - extent[0]) / resolution, 2), Math.pow((extent[3] - extent[1]) / resolution, 2)));\n                  if (size > 150) {\n                    //FIXME Do not hard-code a size of 150\n                    styleGeom = new _Point2.default(geom.getFlatMidpoint());\n                  }\n                }\n              }\n              if (type !== 2 || styleGeom) {\n                ++stylesLength;\n                if (feature.styleIds[zoom].indexOf(_layerId) === -1) {\n                  feature.styleIds[zoom].push(_layerId);\n                }\n                style = styles[stylesLength];\n                if (!style || !style.getImage() || style.getFill() || style.getStroke()) {\n                  style = styles[stylesLength] = new _Style2.default();\n                }\n                style.setGeometry(styleGeom);\n                var iconSize = getValue(_layerId, layout, 'icon-size', zoom, properties);\n                var iconColor = paint['icon-color'] !== undefined ? getValue(_layerId, paint, 'icon-color', zoom, properties) : null;\n                var icon_cache_key = icon + '.' + iconSize;\n                if (iconColor !== null) {\n                  icon_cache_key += '.' + iconColor;\n                }\n                iconImg = iconImageCache[icon_cache_key];\n                if (!iconImg) {\n                  var _spriteImageData = spriteData[icon];\n                  if (iconColor !== null) {\n                    // cut out the sprite and color it\n                    color = colorWithOpacity(iconColor, 1);\n                    var _canvas = document.createElement('canvas');\n                    _canvas.width = _spriteImageData.width;\n                    _canvas.height = _spriteImageData.height;\n                    var _ctx2 = _canvas.getContext('2d');\n                    _ctx2.drawImage(spriteImage, _spriteImageData.x, _spriteImageData.y, _spriteImageData.width, _spriteImageData.height, 0, 0, _spriteImageData.width, _spriteImageData.height);\n                    var data = _ctx2.getImageData(0, 0, _canvas.width, _canvas.height);\n                    for (var c = 0, cc = data.data.length; c < cc; c += 4) {\n                      data.data[c] = color[0];\n                      data.data[c + 1] = color[1];\n                      data.data[c + 2] = color[2];\n                    }\n                    _ctx2.putImageData(data, 0, 0);\n                    iconImg = iconImageCache[icon_cache_key] = new _Icon2.default({\n                      img: _canvas,\n                      imgSize: [_canvas.width, _canvas.height],\n                      scale: iconSize / _spriteImageData.pixelRatio\n                    });\n                  } else {\n                    iconImg = iconImageCache[icon_cache_key] = new _Icon2.default({\n                      img: spriteImage,\n                      imgSize: spriteImgSize,\n                      size: [_spriteImageData.width, _spriteImageData.height],\n                      offset: [_spriteImageData.x, _spriteImageData.y],\n                      scale: iconSize / _spriteImageData.pixelRatio\n                    });\n                  }\n                }\n                iconImg.setRotation((0, _util.deg2rad)(getValue(_layerId, layout, 'icon-rotate', zoom, properties)));\n                iconImg.setOpacity(getValue(_layerId, paint, 'icon-opacity', zoom, properties));\n                style.setImage(iconImg);\n                text = style.getText();\n                style.setText(undefined);\n                style.setZIndex(99999 - index);\n                hasImage = true;\n                skipLabel = false;\n              } else {\n                skipLabel = true;\n              }\n            }\n          }\n        }\n\n        if (type == 1 && 'circle-radius' in paint) {\n          ++stylesLength;\n          if (feature.styleIds[zoom].indexOf(_layerId) === -1) {\n            feature.styleIds[zoom].push(_layerId);\n          }\n          style = styles[stylesLength];\n          if (!style || !style.getImage() || style.getFill() || style.getStroke()) {\n            style = styles[stylesLength] = new _Style2.default();\n          }\n          var circleRadius = getValue(_layerId, paint, 'circle-radius', zoom, properties);\n          var circleStrokeColor = getValue(_layerId, paint, 'circle-stroke-color', zoom, properties);\n          var circleColor = getValue(_layerId, paint, 'circle-color', zoom, properties);\n          var circleOpacity = getValue(_layerId, paint, 'circle-opacity', zoom, properties);\n          var circleStrokeWidth = getValue(_layerId, paint, 'circle-stroke-width', zoom, properties);\n          var cache_key = circleRadius + '.' + circleStrokeColor + '.' + circleColor + '.' + circleOpacity + '.' + circleStrokeWidth;\n          iconImg = iconImageCache[cache_key];\n          if (!iconImg) {\n            iconImg = new _Circle2.default({\n              radius: circleRadius,\n              stroke: circleStrokeWidth === 0 ? undefined : new _Stroke2.default({\n                width: circleStrokeWidth,\n                color: colorWithOpacity(circleStrokeColor, circleOpacity)\n              }),\n              fill: new _Fill2.default({\n                color: colorWithOpacity(circleColor, circleOpacity)\n              })\n            });\n          }\n          style.setImage(iconImg);\n          text = style.getText();\n          style.setText(undefined);\n          style.setGeometry(undefined);\n          style.setZIndex(99999 - index);\n          hasImage = true;\n        }\n\n        var label = void 0;\n        if ('text-field' in layout) {\n          var textField = getValue(_layerId, layout, 'text-field', zoom, properties);\n          label = fromTemplate(textField, properties);\n        }\n        if (label && !skipLabel) {\n          if (!hasImage) {\n            ++stylesLength;\n            if (feature.styleIds[zoom].indexOf(_layerId) === -1) {\n              feature.styleIds[zoom].push(_layerId);\n            }\n            style = styles[stylesLength];\n            if (!style || !style.getText() || style.getFill() || style.getStroke()) {\n              style = styles[stylesLength] = new _Style2.default();\n            }\n            style.setImage(undefined);\n            style.setGeometry(undefined);\n          }\n          if (!style.getText()) {\n            style.setText(text || new _Text2.default());\n          }\n          text = style.getText();\n          var textSize = getValue(_layerId, layout, 'text-size', zoom, properties);\n          var font = (0, _mapboxToCssFont2.default)(chooseFont(getValue(_layerId, layout, 'text-font', zoom, properties)), textSize);\n          var textTransform = layout['text-transform'];\n          if (textTransform == 'uppercase') {\n            label = label.toUpperCase();\n          } else if (textTransform == 'lowercase') {\n            label = label.toLowerCase();\n          }\n          var wrappedLabel = type == 2 ? label : wrapText(label, font, getValue(_layerId, layout, 'text-max-width', zoom, properties));\n          text.setText(wrappedLabel);\n          text.setFont(font);\n          text.setRotation((0, _util.deg2rad)(getValue(_layerId, layout, 'text-rotate', zoom, properties)));\n          var textAnchor = getValue(_layerId, layout, 'text-anchor', zoom, properties);\n          var placement = hasImage || type == 1 ? 'point' : getValue(_layerId, layout, 'symbol-placement', zoom, properties);\n          text.setPlacement(placement);\n          if (placement == 'point') {\n            var textAlign = 'center';\n            if (textAnchor.indexOf('left') !== -1) {\n              textAlign = 'left';\n            } else if (textAnchor.indexOf('right') !== -1) {\n              textAlign = 'right';\n            }\n            text.setTextAlign(textAlign);\n          } else {\n            text.setTextAlign();\n          }\n          var textBaseline = 'middle';\n          if (textAnchor.indexOf('bottom') == 0) {\n            textBaseline = 'bottom';\n          } else if (textAnchor.indexOf('top') == 0) {\n            textBaseline = 'top';\n          }\n          text.setTextBaseline(textBaseline);\n          var textOffset = getValue(_layerId, layout, 'text-offset', zoom, properties);\n          var textTranslate = getValue(_layerId, paint, 'text-translate', zoom, properties);\n          text.setOffsetX(textOffset[0] * textSize + textTranslate[0]);\n          text.setOffsetY(textOffset[1] * textSize + textTranslate[1]);\n          opacity = getValue(_layerId, paint, 'text-opacity', zoom, properties);\n          var textColor = new _Fill2.default();\n\n          textColor.setColor(colorWithOpacity(getValue(_layerId, paint, 'text-color', zoom, properties), opacity));\n          text.setFill(textColor);\n          var haloColor = colorWithOpacity(getValue(_layerId, paint, 'text-halo-color', zoom, properties), opacity);\n          if (haloColor) {\n            var textHalo = new _Stroke2.default();\n            textHalo.setColor(haloColor);\n            textHalo.setWidth(getValue(_layerId, paint, 'text-halo-width', zoom, properties));\n            text.setStroke(textHalo);\n          } else {\n            text.setStroke(undefined);\n          }\n          style.setZIndex(99999 - index);\n        }\n      }\n    }\n\n    if (stylesLength > -1) {\n      styles.length = stylesLength + 1;\n      return styles;\n    }\n  };\n\n  olLayer.setStyle(styleFunction);\n  olLayer.set('mapbox-source', mapboxSource);\n  olLayer.set('mapbox-layers', mapboxLayers);\n  return styleFunction;\n};\n\nvar _Style = __webpack_require__(/*! ol/style/Style */ \"ol/style/Style\");\n\nvar _Style2 = _interopRequireDefault(_Style);\n\nvar _Fill = __webpack_require__(/*! ol/style/Fill */ \"ol/style/Fill\");\n\nvar _Fill2 = _interopRequireDefault(_Fill);\n\nvar _Stroke = __webpack_require__(/*! ol/style/Stroke */ \"ol/style/Stroke\");\n\nvar _Stroke2 = _interopRequireDefault(_Stroke);\n\nvar _Icon = __webpack_require__(/*! ol/style/Icon */ \"ol/style/Icon\");\n\nvar _Icon2 = _interopRequireDefault(_Icon);\n\nvar _Text = __webpack_require__(/*! ol/style/Text */ \"ol/style/Text\");\n\nvar _Text2 = _interopRequireDefault(_Text);\n\nvar _Circle = __webpack_require__(/*! ol/style/Circle */ \"ol/style/Circle\");\n\nvar _Circle2 = _interopRequireDefault(_Circle);\n\nvar _Point = __webpack_require__(/*! ol/geom/Point */ \"ol/geom/Point\");\n\nvar _Point2 = _interopRequireDefault(_Point);\n\nvar _deref = __webpack_require__(/*! @mapbox/mapbox-gl-style-spec/deref */ \"./node_modules/@mapbox/mapbox-gl-style-spec/deref.js\");\n\nvar _deref2 = _interopRequireDefault(_deref);\n\nvar _function = __webpack_require__(/*! @mapbox/mapbox-gl-style-spec/function */ \"./node_modules/@mapbox/mapbox-gl-style-spec/function/index.js\");\n\nvar _function2 = _interopRequireDefault(_function);\n\nvar _feature_filter = __webpack_require__(/*! @mapbox/mapbox-gl-style-spec/feature_filter */ \"./node_modules/@mapbox/mapbox-gl-style-spec/feature_filter/index.js\");\n\nvar _feature_filter2 = _interopRequireDefault(_feature_filter);\n\nvar _mapboxToCssFont = __webpack_require__(/*! mapbox-to-css-font */ \"./node_modules/mapbox-to-css-font/index.js\");\n\nvar _mapboxToCssFont2 = _interopRequireDefault(_mapboxToCssFont);\n\nvar _util = __webpack_require__(/*! ./util */ \"./util.js\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar functionTypes = {\n  'line-miter-limit': 'interpolated',\n  'fill-opacity': 'interpolated',\n  'line-opacity': 'interpolated',\n  'line-width': 'interpolated',\n  'text-halo-width': 'interpolated',\n  'text-max-width': 'interpolated',\n  'text-offset': 'interpolated',\n  'text-opacity': 'interpolated',\n  'text-rotate': 'interpolated',\n  'text-size': 'interpolated',\n  'icon-opacity': 'interpolated',\n  'icon-rotate': 'interpolated',\n  'icon-size': 'interpolated',\n  'icon-color': 'interpolated',\n  'circle-radius': 'interpolated',\n  'circle-opacity': 'interpolated',\n  'circle-stroke-width': 'interpolated',\n  'circle-color': 'interpolated',\n  'circle-stroke-color': 'interpolated',\n  'text-halo-color': 'interpolated',\n  'text-color': 'interpolated',\n  'line-color': 'interpolated',\n  'fill-outline-color': 'interpolated',\n  'fill-color': 'interpolated',\n  'icon-image': 'piecewise-constant',\n  'line-cap': 'piecewise-constant',\n  'line-join': 'piecewise-constant',\n  'line-dasharray': 'piecewise-constant',\n  'symbol-placement': 'piecewise-constant',\n  'text-anchor': 'piecewise-constant',\n  'text-field': 'piecewise-constant',\n  'text-font': 'piecewise-constant'\n};\n\nvar defaults = {\n  'fill-opacity': 1,\n  'line-cap': 'butt',\n  'line-join': 'miter',\n  'line-miter-limit': 2,\n  'line-opacity': 1,\n  'line-width': 1,\n  'symbol-placement': 'point',\n  'text-anchor': 'center',\n  'text-color': '#000000',\n  'text-font': ['Open Sans Regular', 'Arial Unicode MS Regular'],\n  'text-halo-color': 'rgba(0, 0, 0, 0)',\n  'text-halo-width': 0,\n  'text-max-width': 10,\n  'text-offset': [0, 0],\n  'text-translate': [0, 0],\n  'text-opacity': 1,\n  'text-rotate': 0,\n  'text-size': 16,\n  'icon-opacity': 1,\n  'icon-rotate': 0,\n  'icon-size': 1,\n  'circle-color': '#000000',\n  'circle-stroke-color': '#000000',\n  'circle-opacity': 1,\n  'circle-stroke-width': 0\n};\n\nvar types = {\n  'Point': 1,\n  'MultiPoint': 1,\n  'LineString': 2,\n  'MultiLineString': 2,\n  'Polygon': 3,\n  'MultiPolygon': 3\n};\n\nvar functionCache = {};\n\nfunction getValue(layerId, layoutOrPaint, property, zoom, properties) {\n  if (!functionCache[layerId]) {\n    functionCache[layerId] = {};\n  }\n  var functions = functionCache[layerId];\n  if (!functions[property]) {\n    var value = layoutOrPaint[property];\n    if (value === undefined) {\n      value = defaults[property];\n    }\n    functions[property] = (0, _function2.default)(value, {\n      function: functionTypes[property],\n      type: property.indexOf('color') !== -1 ? 'color' : (typeof value === 'undefined' ? 'undefined' : _typeof(value)) == 'object' && value.stops && typeof value.stops[0][0] == 'number' ? 'number' : undefined\n    });\n  }\n  return functions[property](zoom, properties);\n}\n\nvar fontMap = {};\n\nfunction chooseFont(fonts, availableFonts) {\n  if (fontMap[fonts]) {\n    return fontMap[fonts];\n  }\n  if (availableFonts) {\n    for (var i = 0, ii = fonts.length; i < ii; ++i) {\n      var font = fonts[i];\n      if (availableFonts.indexOf(font) != -1) {\n        fontMap[fonts] = font;\n        break;\n      }\n    }\n    if (!fontMap[fonts]) {\n      // fallback font\n      fontMap[fonts] = fonts[fonts.length - 1];\n    }\n  } else {\n    fontMap[fonts] = fonts[0];\n  }\n  return fontMap[fonts];\n}\n\nvar filterCache = {};\n\nfunction evaluateFilter(layerId, filter, feature) {\n  if (!(layerId in filterCache)) {\n    filterCache[layerId] = (0, _feature_filter2.default)(filter);\n  }\n  return filterCache[layerId](feature);\n}\n\nvar colorCache = {};\n\nfunction colorWithOpacity(color, opacity) {\n  if (color && opacity !== undefined) {\n    var colorData = colorCache[color];\n    if (!colorData) {\n      colorCache[color] = colorData = {\n        color: [color[0] * 255 / color[3], color[1] * 255 / color[3], color[2] * 255 / color[3], color[3]],\n        opacity: color[3]\n      };\n    }\n    color = colorData.color;\n    color[3] = colorData.opacity * opacity;\n    if (color[3] === 0) {\n      color = undefined;\n    }\n  }\n  return color;\n}\n\nvar templateRegEx = /^([^]*)\\{(.*)\\}([^]*)$/;\n\nfunction fromTemplate(text, properties) {\n  var parts = void 0;\n  do {\n    parts = text.match(templateRegEx);\n    if (parts) {\n      var value = properties[parts[2]] || '';\n      text = parts[1] + value + parts[3];\n    }\n  } while (parts);\n  return text;\n}\n\nvar emptyObj = {};\n\n/**\r\n * Creates a style function from the `glStyle` object for all layers that use\r\n * the specified `source`, which needs to be a `\"type\": \"vector\"` or\r\n * `\"type\": \"geojson\"` source and applies it to the specified OpenLayers layer.\r\n *\r\n * @param {ol.layer.Vector|ol.layer.VectorTile} olLayer OpenLayers layer to\r\n * apply the style to. In addition to the style, the layer will get two\r\n * properties: `mapbox-source` will be the `id` of the `glStyle`'s source used\r\n * for the layer, and `mapbox-layers` will be an array of the `id`s of the\r\n * `glStyle`'s layers.\r\n * @param {string|Object} glStyle Mapbox Style object.\r\n * @param {string|Array<string>} source `source` key or an array of layer `id`s\r\n * from the Mapbox Style object. When a `source` key is provided, all layers for\r\n * the specified source will be included in the style function. When layer `id`s\r\n * are provided, they must be from layers that use the same source.\r\n * @param {Array<number>} [resolutions=[78271.51696402048, 39135.75848201024,\r\n * 19567.87924100512, 9783.93962050256, 4891.96981025128, 2445.98490512564,\r\n * 1222.99245256282, 611.49622628141, 305.748113140705, 152.8740565703525,\r\n * 76.43702828517625, 38.21851414258813, 19.109257071294063, 9.554628535647032,\r\n * 4.777314267823516, 2.388657133911758, 1.194328566955879, 0.5971642834779395,\r\n * 0.29858214173896974, 0.14929107086948487, 0.07464553543474244]]\r\n * Resolutions for mapping resolution to zoom level.\r\n * @param {Object} [spriteData=undefined] Sprite data from the url specified in\r\n * the Mapbox Style object's `sprite` property. Only required if a `sprite`\r\n * property is specified in the Mapbox Style object.\r\n * @param {Object} [spriteImageUrl=undefined] Sprite image url for the sprite\r\n * specified in the Mapbox Style object's `sprite` property. Only required if a\r\n * `sprite` property is specified in the Mapbox Style object.\r\n * @param {Array<string>} [fonts=undefined] Array of available fonts, using the\r\n * same font names as the Mapbox Style object. If not provided, the style\r\n * function will always use the first font from the font array.\r\n * @return {ol.style.StyleFunction} Style function for use in\r\n * `ol.layer.Vector` or `ol.layer.VectorTile`.\r\n */\n\n//# sourceURL=webpack://olms/./stylefunction.js?");

/***/ }),

/***/ "./util.js":
/*!*****************!*\
  !*** ./util.js ***!
  \*****************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.deg2rad = deg2rad;\nexports.getZoomForResolution = getZoomForResolution;\nfunction deg2rad(degrees) {\n  return degrees * Math.PI / 180;\n}\n\nfunction getZoomForResolution(resolution, resolutions) {\n  var i = 0;\n  var ii = resolutions.length;\n  for (; i < ii; ++i) {\n    var candidate = resolutions[i];\n    if (candidate < resolution && i + 1 < ii) {\n      var zoomFactor = resolutions[i] / resolutions[i + 1];\n      return i + Math.log(resolutions[i] / resolution) / Math.log(zoomFactor);\n    }\n  }\n  return ii - 1;\n}\n\n//# sourceURL=webpack://olms/./util.js?");

/***/ }),

/***/ "ol/Map":
/*!*************************!*\
  !*** external "ol.Map" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = ol.Map;\n\n//# sourceURL=webpack://olms/external_%22ol.Map%22?");

/***/ }),

/***/ "ol/Observable":
/*!********************************!*\
  !*** external "ol.Observable" ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = ol.Observable;\n\n//# sourceURL=webpack://olms/external_%22ol.Observable%22?");

/***/ }),

/***/ "ol/format/GeoJSON":
/*!************************************!*\
  !*** external "ol.format.GeoJSON" ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = ol.format.GeoJSON;\n\n//# sourceURL=webpack://olms/external_%22ol.format.GeoJSON%22?");

/***/ }),

/***/ "ol/format/MVT":
/*!********************************!*\
  !*** external "ol.format.MVT" ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = ol.format.MVT;\n\n//# sourceURL=webpack://olms/external_%22ol.format.MVT%22?");

/***/ }),

/***/ "ol/geom/Point":
/*!********************************!*\
  !*** external "ol.geom.Point" ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = ol.geom.Point;\n\n//# sourceURL=webpack://olms/external_%22ol.geom.Point%22?");

/***/ }),

/***/ "ol/layer/Tile":
/*!********************************!*\
  !*** external "ol.layer.Tile" ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = ol.layer.Tile;\n\n//# sourceURL=webpack://olms/external_%22ol.layer.Tile%22?");

/***/ }),

/***/ "ol/layer/Vector":
/*!**********************************!*\
  !*** external "ol.layer.Vector" ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = ol.layer.Vector;\n\n//# sourceURL=webpack://olms/external_%22ol.layer.Vector%22?");

/***/ }),

/***/ "ol/layer/VectorTile":
/*!**************************************!*\
  !*** external "ol.layer.VectorTile" ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = ol.layer.VectorTile;\n\n//# sourceURL=webpack://olms/external_%22ol.layer.VectorTile%22?");

/***/ }),

/***/ "ol/proj":
/*!**************************!*\
  !*** external "ol.proj" ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = ol.proj;\n\n//# sourceURL=webpack://olms/external_%22ol.proj%22?");

/***/ }),

/***/ "ol/source/TileJSON":
/*!*************************************!*\
  !*** external "ol.source.TileJSON" ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = ol.source.TileJSON;\n\n//# sourceURL=webpack://olms/external_%22ol.source.TileJSON%22?");

/***/ }),

/***/ "ol/source/Vector":
/*!***********************************!*\
  !*** external "ol.source.Vector" ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = ol.source.Vector;\n\n//# sourceURL=webpack://olms/external_%22ol.source.Vector%22?");

/***/ }),

/***/ "ol/source/VectorTile":
/*!***************************************!*\
  !*** external "ol.source.VectorTile" ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = ol.source.VectorTile;\n\n//# sourceURL=webpack://olms/external_%22ol.source.VectorTile%22?");

/***/ }),

/***/ "ol/source/XYZ":
/*!********************************!*\
  !*** external "ol.source.XYZ" ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = ol.source.XYZ;\n\n//# sourceURL=webpack://olms/external_%22ol.source.XYZ%22?");

/***/ }),

/***/ "ol/style/Circle":
/*!**********************************!*\
  !*** external "ol.style.Circle" ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = ol.style.Circle;\n\n//# sourceURL=webpack://olms/external_%22ol.style.Circle%22?");

/***/ }),

/***/ "ol/style/Fill":
/*!********************************!*\
  !*** external "ol.style.Fill" ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = ol.style.Fill;\n\n//# sourceURL=webpack://olms/external_%22ol.style.Fill%22?");

/***/ }),

/***/ "ol/style/Icon":
/*!********************************!*\
  !*** external "ol.style.Icon" ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = ol.style.Icon;\n\n//# sourceURL=webpack://olms/external_%22ol.style.Icon%22?");

/***/ }),

/***/ "ol/style/Stroke":
/*!**********************************!*\
  !*** external "ol.style.Stroke" ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = ol.style.Stroke;\n\n//# sourceURL=webpack://olms/external_%22ol.style.Stroke%22?");

/***/ }),

/***/ "ol/style/Style":
/*!*********************************!*\
  !*** external "ol.style.Style" ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = ol.style.Style;\n\n//# sourceURL=webpack://olms/external_%22ol.style.Style%22?");

/***/ }),

/***/ "ol/style/Text":
/*!********************************!*\
  !*** external "ol.style.Text" ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = ol.style.Text;\n\n//# sourceURL=webpack://olms/external_%22ol.style.Text%22?");

/***/ }),

/***/ "ol/tilegrid":
/*!******************************!*\
  !*** external "ol.tilegrid" ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = ol.tilegrid;\n\n//# sourceURL=webpack://olms/external_%22ol.tilegrid%22?");

/***/ })

/******/ })["default"];